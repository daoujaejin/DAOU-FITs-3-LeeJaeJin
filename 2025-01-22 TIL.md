# 계층 쿼리 연습

```sql
-- 계층 쿼리 조별 문제

-- 1. 직원 계층에서 상사의 이름 표시
-- 직원의 계층 구조를 조회하되 각 계층에서 상사 이름도 함께 표시하세요. 
-- 출력 컬럼은 LEVEL, 사번, 이름, 직무, 상사의 사번, 상사의 이름입니다. 
-- (단, 상사가 없는 경우 ‘대표’라고 표시하고 계층별로 이름으로 오름차순 정렬합니다.)
SELECT LEVEL, NAME 이름, JOB_ID 직무, MANAGER_ID "상사의 사번",
    CASE 
        WHEN MANAGER_ID IS NULL THEN '대표'
        ELSE (SELECT NAME FROM EMPLOYEES WHERE EMPLOYEE_ID = E.MANAGER_ID)
    END "상사의 이름"
FROM EMPLOYEES E
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
ORDER SIBLINGS BY 이름;

-- 2. 각 계층별 급여 순위
-- 직원 계층 쿼리를 작성하고 각 계층별로 급여 상위 3위 까지의 직원들만 조회하세요. 
-- 출력 컬럼은 LEVEL, 사번, 이름, 급여입니다.
SELECT "LEVEL", 사번, 이름, 급여 FROM (
    SELECT LEVEL "LEVEL", EMPLOYEE_ID 사번, NAME 이름, SALARY 급여,
        ROW_NUMBER() OVER (PARTITION BY LEVEL ORDER BY SALARY) R
    FROM EMPLOYEES
    START WITH MANAGER_ID IS NULL
    CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID)
WHERE R <= 3;

-- 3. 각 계층별 평균 급여
-- 직원 계층 구조를 생성하고 각 계층별 평균 급여와 함께 출력하세요. 
-- 출력 컬럼은 LEVEL, 사번, 이름, 급여, 해당 계층의 평균 급여이고 평균 급여는 반올림하여 정수로 표현합니다.

SELECT LEVEL "LEVEL", EMPLOYEE_ID 사번, NAME 이름, SALARY 급여,
    ROUND(AVG(SALARY) OVER (PARTITION BY LEVEL)) "해당 계층의 평균 급여"
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;

-- 4. 상사와의 급여 비교
-- 직원의 급여가 상사의 급여보다 높은 경우만 조회하세요. 
-- 출력 컬럼은 사번, 이름, 급여, 상사 이름, 상사의 급여입니다.
SELECT * FROM (
    SELECT EMPLOYEE_ID 사번, NAME 이름, SALARY 급여,
        (SELECT NAME FROM EMPLOYEES E2 WHERE E1.MANAGER_ID = E2.EMPLOYEE_ID) "상사 이름",
        (SELECT SALARY FROM EMPLOYEES E2 WHERE E1.MANAGER_ID = E2.EMPLOYEE_ID) "상사 급여"
    FROM EMPLOYEES E1)
WHERE 급여 > "상사 급여";

-- 5. 직원의 부서 경로 조회
-- 각 직원이 속한 부서를 포함하여 해당 직원의 부서명 경로를 표시하세요. 
-- 부서가 없는 경우 "No DEPT"로 표시하세요. 출력 컬럼은 이름, 부서명, 부서명 경로입니다.
SELECT 이름, 부서명, 
    SYS_CONNECT_BY_PATH((
        CASE 
        WHEN 부서명 IS NOT NULL THEN 부서명
        ELSE 'No DEPT'
        END), '>') "부서명 경로"
FROM (
    SELECT  NAME 이름, EMPLOYEE_ID, MANAGER_ID,
        (SELECT DEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = E.DEPARTMENT_ID) 부서명
    FROM EMPLOYEES E)
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
```

# 그룹함수

- 데이터를 특정 기준으로 그룹핑하여 요약, 집계하는 데 사용
- 데이터 분석 및 보고서를 생성
- 다차원 데이터를 요약하는 데 활용
- 중첩괄호는 괄호 안의 열들을 하나로 보게 한다.

## 주요 그룹 함수

- ROLLUP
- CUBE: ROLLUP의 확장
- GROUPING SETS
- GROUPING

## ROLLUP

- 소계와 총계를 한 번에 생성 (단방향)
- 지정된 컬럼 순서대로 그룹핑
- 컬럼의 순서에 따라 결과 데이터가 달라짐

→ 보고서, 요약 데이터 생성

```sql
-- 기본
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY JOB_ID, DEPARTMENT_ID
ORDER BY JOB_ID, DEPARTMENT_ID;

-- CUBE
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;
```

## CUBE

- 소계와 총계를 한 번에 생성
- 모든 가능한 조합에 대한 집계를 생성
- 컬럼의 순서가 달라져도 결과 데이터는 동일
- ROLLUP보다 더 많은 집계 결과를 생성

= ROLLUP 확장판

- CUBE를 사용하다가 서버에 문제가 생길 수 있음
    
    → 실무에서 사용 잘 하지 않음
    

```sql
-- CUBE
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY CUBE(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY CUBE(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;
```

## GROUPING SETS

- 원하는 조합에 대해서만 집계를 생성
- ROLLUP, CUBE보다 더 유연한 방식 제공
- 불필요한 집계 생성을 방지
- 서로 다른 기준으로 그룹핑한 데이터 셋을 UNION ALL한 결과와 동일

```sql
-- GROUPING SETS
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY GROUPING SETS(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, DEPARTMENT_ID, ())
ORDER BY JOB_ID, DEPARTMENT_ID;

-- UNION ALL과 같음
SELECT JOB_ID 직무, NULL 부서명, COUNT(*) 
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY JOB_ID
UNION ALL
SELECT NULL 직무, DEPARTMENT_ID 부서명, COUNT(*)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY JOB_ID, DEPARTMENT_ID
ORDER BY 직무, 부서명;
```

## GROUPING

- 집계 결과가 실제 데이터인지, 집계 데이터인지 표시
- 집계된 행이면 1, 아니면 0 반환

```sql
-- GROUPING
SELECT JOB_ID,
    COUNT(*) AS CNT,
    GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT,
    GROUPING(JOB_ID),
    GROUPING(DEPARTMENT_ID)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

SELECT CASE
        WHEN GROUPING(JOB_ID) = 0 THEN JOB_ID
        WHEN GROUPING(JOB_ID) = 1 THEN '총합'
    END JOB_ID,
    COUNT(*) AS CNT,
    GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;
```

# 그룹함수 연습

```sql
-- 그룹함수 문제

-- 6. 직무별, 지역별 대출 금액 합계 조회
-- 대출 테이블에서 직무별, 지점별 대출 금액 합계를 계산하고 모든 조합, 즉 다차원 집계를 표시하세요.
SELECT E.JOB_ID 직무, L.BRANCH_ID 지점, SUM(L.AMOUNT) "대출 금액 합계"
FROM EMPLOYEES E, LOANS L
WHERE E.EMPLOYEE_ID = L.CUSTOMER_ID
GROUP BY ROLLUP(E.JOB_ID, L.BRANCH_ID)
ORDER BY E.JOB_ID, L.BRANCH_ID;

-- 7. 직원 급여 통계 요약 (GROUPING SETS)
-- 사원 테이블에서 전체 급여 합계, 부서별 급여 합계, 직무별 급여 합계를 각각 표시하세요.
SELECT DEPARTMENT_ID, JOB_ID, SUM(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL AND JOB_ID IS NOT NULL
GROUP BY GROUPING SETS(DEPARTMENT_ID, JOB_ID, ())
ORDER BY DEPARTMENT_ID, JOB_ID;

-- 8. 대출 통계 요약
-- 대출 테이블에서 지점별, 대출 상태별 금액 합계를 계산하고 각 지점별 소계와 전체 합계를 표시하세요. 
-- 단, 지점별 소계를 나타내는 행은 상태값 컬럼에 ‘==========’ 표시를 해주고 총계는 ‘Total’로 표시합니다.
SELECT NVL(TO_CHAR(BRANCH_ID), 'Total') "지점", 
    NVL(STATUS, '==========') "대출 상태", 
    SUM(AMOUNT) "금액 합계"
FROM LOANS
GROUP BY ROLLUP(BRANCH_ID, STATUS)
ORDER BY BRANCH_ID, STATUS;

-- 9. 계층별 직원 수 조회
-- 직원의 계층 구조를 생성하고 각 계층별 직원의 수를 출력하세요.
SELECT "LEVEL", COUNT(*) "직원의 수"
FROM (
    SELECT EMPLOYEE_ID, LEVEL "LEVEL"
    FROM EMPLOYEES
    START WITH MANAGER_ID IS NULL
    CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID)
GROUP BY "LEVEL";

-- 10. 고객별, 대출 상태별 대출 금액
-- 고객별, 대출 상태별 대출 금액과 고객별 대출 금액 소계, 그리고 전체 대출 금액 합계를 구하세요. 
-- 출력 컬럼은 고객 이름, 대출 상태, 대출 금액입니다. 
-- 고객별 대출 금액 소계는 ‘All Status’로 표시하고 전체 대출 금액 합계는 Total로 표시해 주세요.
SELECT NVL(C.NAME, 'Total') "고객 이름", NVL(L.STATUS, 'All Status') "대출 상태", SUM(L.AMOUNT) "대출 금액 합계"
FROM LOANS L
LEFT JOIN CUSTOMERS C
    ON L.CUSTOMER_ID = C.CUSTOMER_ID
GROUP BY ROLLUP(C.NAME, L.STATUS)
ORDER BY C.NAME, L.STATUS;
```

# 뷰

- SQL 쿼리 결과를 기반으로 만들어지는 가상 테이블
- 실제 데이터를 저장하지 않고 테이블처럼 동작

## 뷰의 장점

- 복잡한 쿼리를 단순화하여 사용자가 쉽게 접근 가능
- 특정 열, 행에 대한 접근을 제한하여 보안 강화
- 기본 테이블 구조를 추상화 → 데이터 변경시 유연성 제공
- 재사용 가능한 쿼리 인터페이스 제공

## 뷰의 유형

- **단순 뷰**
    
    단일 테이블을 기반
    
    거의 없음
    
- **복합 뷰**
    
    여러 테이블, 함수, 그룹화를 포함
    
- **물리적 뷰**
    
    쿼리 결과를 물리적으로 저장하여 성능 향상
    

## 문법

```sql
CREATE VIEW 뷰_이름 AS
	SELECT 컬럼1, 컬럼2 FROM 테이블 WHERE 조건;
```

```sql
-- 예시
CREATE OR REPLACE VIEW EMPLOYEE_VIEW AS
    SELECT EMPLOYEE_ID, NAME, JOB_ID, DEPARTMENT_ID, SALARY
    FROM EMPLOYEES
    WHERE MOD(DEPARTMENT_ID, 2) = 0;

-- 조회
SELECT * FROM EMPLOYEE_VIEW WHERE SALARY > 5000;
```

## 뷰 업데이트

- 단일 테이블의 뷰는 업데이트 가능
- 업데이트는 기본 테이블에 반영
- PK 또는 고유 식별 컬럼이 포함되어 있어야 함
- 뷰에 포함된 열이 기본 테이블의 실제 열이어야 함
- GROUP BY, DISTINCT, 또는 집계 함수가 포함되지 않아야 함

```sql
-- 뷰 업데이트
UPDATE EMPLOYEE_VIEW SET SALARY = 6000
    WHERE EMPLOYEE_ID = 101;
```

## 뷰 삭제

- DROP VIEW 명령어 사용

```sql
-- 뷰 삭제
DROP VIEW EMPLOYEE_VIEW;
```

## 뷰의 단점

- 복잡한 뷰는 성능 저하를 초래
- 특정 뷰에서는 제한된 DML 작업만 가능
- 기본 테이블 구조 변경 시 유지 관리 필요
- 타 팀에서 받은 뷰를 튜닝하기 어려움

## 물리적 뷰

- 쿼리 결과를 물리적으로 저장하여 성능 향상
- 대규모 데이터 분석, 보고서 생성에 유용

```sql
-- 물리적 뷰
CREATE MATERIALIZED VIEW JOB_SALARY_SUMMARY AS
    SELECT JOB_ID,
        SUM(SALARY) AS TOTAL_SALARY
    FROM EMPLOYEES
    GROUP BY JOB_ID;
```

## 뷰 vs 테이블

- 테이블: 데이터를 저장할 저장 공간 필요
- 뷰: 가상 테이블로 데이터 저장 없음
- 테이블은 모든 DML 작업 가능, 뷰는 제한적

## 뷰의 실무 활용 사례

- 민감 데이터 제한
- 보고서, 대시보드용 단순화된 데이터 제공
- 빠르게 로딩되어야 하는 페이지에 속도를 위해 사용
- 복잡한 멀티 조인 쿼리를 간소화

## 뷰 사용 권장 사항

- 반복적인 쿼리를 단순화할 때 사용
- 실시간 작업에서는 과도한 조인 포함 뷰 사용 자제
- 기본 테이블 스키마 변경 시 뷰를 점검

# 시퀀스

- 자동으로 고유한 숫자를 생성하는 오라클 객체
- 주로 기본 키나 고유한 값이 필요한 컬럼에 사용
- CREATE SEQUENCE 명령어로 생성

## 시퀀스 특징

- 고유한 숫자 생성 보장
- 숫자의 증가/감소 방향 설정 가능
- 생성 규짗 정의 가능
- 캐싱을 사용하여 성능 최적화 가능

```sql
-- 시퀀스
CREATE SEQUENCE EMPLOYEE_SEQ
    START WITH 1
    INCREMENT BY 1
    MAXVALUE 99999
    NOCACHE;
    
-- NEXTVAL
SELECT EMPLOYEE_SEQ.NEXTVAL FROM DUAL;

-- CURRVAL
SELECT EMPLOYEE_SEQ.CURRVAL FROM DUAL;

-- 예시
INSERT INTO employees(employee_id, name)
VALUES(EMPLOYEE_SEQ.NEXTVAL,'John Doe');

-- 시퀀스 조회
SELECT sequence_name, last_number
FROM user_sequences;

--시퀀스 변경
ALTER SEQUENCE EMPLOYEE_SEQ
INCREMENT BY 5;

-- 시퀀스 삭제
DROP SEQUENCE EMPLOYEE_SEQ;
```

## 시퀀스 사용 시 유의사항

- DELETE로 삭제된 값은 재사용되지 않음
- 캐싱된 값은 장애 발생 시 손실 가능
- NOCACHE 사용 시 성능 저하 가능

## 시퀀스 실제 활용 사례

- 주문 번호 자동 생성
- 고객 ID, 계좌 번호 생성
- 대량 데이터 삽입 시 고유 키 생성
