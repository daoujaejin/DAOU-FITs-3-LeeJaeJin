# recap test
- 숫자를 0으로 나눈 오류의 e.getMessage()  
  => `/ by zero`
- try ~ catch ~ finally 문에서 finally{} 문은 exception이 발생하거나 하지 않아도 무조건 실행된다.
---

# Exception

## 복습

```java
public class Main {
    public static void main(String[] args) {
        // java에서 exception을 처리하는 구문은 딱 하나이다.
        // try ~ catch 구문을 이용해서 처리한다.
        try {
            int k = 10 / 0; // 실행 시 ArithmaticException instance 실행
            // -> 해당 exception에 대한 catch() 구문이 있어야 한다.
            // -> Exception class로 한번에 처리하기 보다는 세부적인 exception class를 이용하는 것이 좋다.
        } catch(ArithmeticException e) {
            System.out.println("수학 처리에 문제가 있어요!");
        } catch(NullPointerException e) {
            System.out.println("Null 객체예요!");
        } finally {
            
        }
    }
}
```

## throws

예외가 발생했을 때 예외를 자신을 호출한 곳으로 보내는 것

```java
class MyClass {
    public int myMethod() throws Exception {
        //try {
            int k = 100 / 0;
        //} catch(Exception e) {
        
        //}
        return 100;
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass a = new MyClass();
        try {
            a.myMethod();
        } catch(Exception e) {
            System.out.println("예외 발생!");
        }
    }
}
```

- main() method에 `throws Exception` 을 붙이면 예외 처리를 할 수 없게 된다.

## 사용자 정의 Exception

- java에서 제공하는 기존의 예외 class 말고, 직접 예외를 정의하여 예외 class를 만드는 것.
- 특정 상황에 객체가 자동으로 만들어지지 않기 때문에 직접 만들어야 한다.
- 객체를 만들고, `throw` 로 예외를 발생시켜야 한다.

```java
class MyClass extends Exception {
    public MyClass(String msg) {
        super(msg);
    }
}

public class Main {
    public static void main(String[] args) {
        try {
            throw new MyClass("사용자 정의 예외 객체 생성!");
        } catch(Exception e) {
            System.out.println("예외 발생!");
        }
    }
}
```

# JDBC

Java를 이용하여 DB에 있는 값들을 활용하기 위한 API

= Java Database Conectivity

## JDBC Driver

- Java와 DB의 통신을 담당하는 class
- DBMS마다 method가 다르면 유지보수가 어렵기 때문에, 일관적인 사용이 가능하게 한다.
    
    → JDBC Interface만 사용하면 된다. (JDK 안에 들어있다.)
    
- java의 특정 버전 이상에서 원활하게 사용 가능하다. (java 17 이상에서)

## JDBC 사용 6단계

### 1. (JDBC) Driver Loading

프로그램에서 딱 한 번 수행된다.

### 2. 데이터베이스 연결

- 만약 연결이 성공하면 객체가 생성된다.
    
    객체의 Class는 java.sql.Connection class이다.
    
- 연결을 하려면 3가지 정보가 필요하다.
    - 어떤 데이터베이스에 접속하는지에 대한 정보(문자열) ⇒ JDBC_URL
        
        정해진 형식이 있다.
        
    - ID / PW

### 3. SQL을 작성해요

- Statement 종류
    1. **일반 Statement**
        - 단순하다.
        - 기능상으로는 약간 부족하다.
        
        → 거의 사용하지 않음
        
    2. **PreparedStatement**
        - 코드 작성이 편함
        - 효율이 좋음
        - SQL Injection 방지 가능
        
        → 많이 사용
        
    3. **CallableStatement**
        - Stored Procedure를 호출하기 위해서 사용

→ PreparedStatement를 생성

### 4. Query 실행

- **executeUpdate()**
    
    SQL 구문이 `insert`, `update`, `delete` 계열일 때
    
    리턴값 = SQL에 의해서 영향을 받은 행의 수 (int)
    
- **executeQuery()**
    
    SQL 구문이 `select`일 때 사용
    

### 5. 결과 처리

- excuteUpdate()인 경우 반환값
    
    = SQL에 의해서 영향을 받은 행의 수 (int)
    
- excuteQuery()인 경우 반환값
    
    = ResultSet이 결과로 나온다.
    

### 6. 리소스 해제

→ 자바 프로그램과 상관 없는 db의 자원은 리소스 해제를 해주지 않으면 문제가 생길 수 있다.

- 지금 사용된 자원: Connection, PreparedStatement, ResultSet
- 사용된 자원을 해제(`close()` 호출)해야 한다.
- 순서는 자원 생성 순서의 반대로 한다.

```java
import java.sql.*;

public class FirstConnect {
    public static void main(String[] args) {
        try {
            // 1
            Class.forName("oracle.jdbc.driver.OracleDriver");
            System.out.println("드라이버 로딩 성공!");
            // 2
            Connection con = null;
            String JDBC_URL = "jdbc:oracle:thin:@localhost:1521:xe";
            String ID = "C##2"; // 오라클 id
            String PW = "1234"; // 오라클 pw
            con = DriverManager.getConnection(JDBC_URL, ID, PW);
            System.out.println("데이터베이스 연결 성공!");
            // 3
            String sql = "SELECT btitle FROM book WHERE bisbn='89-7914-063-0'";
            // SQL 문장을 얹어서 보낼 Statement 객체를 생성한다.
            // Statement는 크게 3개가 있다.
            // 1. 일반 Statement => 단순, 기능상으로는 약간 부족
            // 2. PreparedStatement => 많이 사용한다.
            //    코드 작성하기 편하고, 효율이 좋다, SQL Injection 방지
            // 3. CallableStatement => Stored Procedure를 호출하기 위해 사용
            PreparedStatement pstmt = con.prepareStatement(sql);
            // Query 실행
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                // 결과가 존재하면
                System.out.println(rs.getString("btitle"));
            } else {
                System.out.println("검색 결과가 없습니다.");
            }
            // 6
            rs.close();
            pstmt.close();
            con.close();
        } catch(ClassNotFoundException e) {
            System.out.println("드라이버를 찾을 수 없어요!");
        } catch(SQLException e1) {
            System.out.println("연결에 문제가 있어요!");
        }
    }
}
```

```java
// 책 제목에 대한 키워드를 입력받아서
// 해당 키워드를 포함하고 있는 책을 검색한 다음
// 해당 책에 대한 책 제목, 저자, 가격 정보를 출력하세요
public class SecondConnect {
    public static void main(String[] args) {
        Connection con = null;
        try {
            // 1. JDBC Driver Loading
            Class.forName("oracle.jdbc.driver.OracleDriver");
            // 2. DB 연결 (Connection)
            String jdbcURL = "jdbc:oracle:thin:@localhost:1521:xe";
            String ID = "C##2";
            String PW = "1234";
            con = DriverManager.getConnection(jdbcURL, ID, PW);
            Scanner s = new Scanner(System.in);
            System.out.println("검색어를 입력하세요: ");
            String keyword = s.nextLine();
            // SQL문장을 만들어야 한다.
            // IN Parameter를 이용해서 query를 작성하는게 좋다.
            String sql = "SELECT btitle, bauthor, bprice ";
            sql += "FROM BOOK WHERE btitle LIKE ?";
            PreparedStatement pstmt = con.prepareStatement(sql);
            // 아직 SQL문장이 완성되지 않아 실행이 안된다.
            pstmt.setString(1, "%" + keyword + "%");
            // 문장이 완성된다.
            // 실행을 시킨다.
            ResultSet rs = pstmt.executeQuery();
            while(rs.next()) {
                System.out.println(rs.getString("btitle")
                        + " " + rs.getString("bauthor")
                        + " " + rs.getString("bprice"));
            }
            rs.close();
            pstmt.close();
            con.close();
        } catch(Exception e) {
            System.out.println("오류");
        }
    }
}
```

## Database

- **Transaction**: 작업(일)의 최소 단위
    
    ex) SQL 구문 5개를 Transaction으로 설정
    
    설정하는 이유: `ACID` 특성을 보장받기 위해서
    
    - **Atomicity** (원자성)
        
        All or Nothing
        
    - **Consistency** (일치성)
    - **Isolation** (독립성)
    - **Durability** (영구성)
- Transaction을 JDBC를 이용해서 설정하려면?
    
    → Connection에 설정
    
    - 아무 설정이 없으면 SQL구문 하나가 한 Transaction이다.
    - 명시적으로 설정하는 방법
        - **transaction 시작**
        
        ```java
        con.setAutoCommit(false); // Transaction 시작
        ```
        
        - **transaction 끝**
        
        명시적으로 con.commit() 혹은 con.rollback()이 호출되면 종료된다.
        
        해당 구문이 없고 connection이 정상 종료되면 con.commit()으로 간주
