# 인덱스

- 데이터베이스 테이블의 검색 성능을 향상시키기 위해 사용되는 특별한 데이터 구조
- 특정 데이터를 빠르게 찾아갈 수 있는 경로를 제공

ex) 도서관의 책 목차와 같은 역할

## 인덱스 사용 목적

- 검색 성능 향상
- 쿼리 실행 시간 단축
- 테이블의 특정 컬럼을 기준으로 데이터 정렬 및 관리

## 인덱스 동작 원리

- **테이블 스캔**
    
    인덱스가 없는 경우 테이블의 모든 데이터를 처음부터 끝까지 읽어야 함
    
- **인덱스 스캔**
    
    인덱스를 사용하여 데이터가 저장된 위치를 빠르게 탐색 가능
    

## 인덱스 구조

- **B-Tree 인덱스**
    
    가장 일반적인 구조
    
    균형 이진트리 형태 → 데이터 검색에 최적화
    
    INSERT, UPDATE의 속도는 느려질 수 있음
    
    한 테이블에 3~4개의 인덱스 정도만 사용하는 가이드라인
    
    루트 노드 → 중간 노드 → 리프 노드 순서로 탐색
    

## Access 방식

- **Sequential Access**
    
    높은 효율
    
    인덱스 Leaf Block을 읽는 방식
    
- **Random Access**
    
    낮은 효율
    
    논리적, 물리적 순서와 무관
    
    한 Block씩 접근
    

## 인덱스의 장단점

- 장점
    - 검색 속도 향상
    - 정렬된 데이터 관리
    - 대용량 데이터 처리
- 단점
    - 추가 저장 공간 필요
    - 쓰기 작업 성능 저하
    - 인덱스 과다 생성 시 비용 증가, 성능 저하

→ 프로젝트 시 인덱스 생성은 가장 마지막에 하기

## 인덱스 유형

- **단일 컬럼 인덱스**
    
    하나의 컬럼만 기준으로 인덱스를 생성
    
    ex) 고객 ID
    
- **결합 인덱스**
    
    두 개 이상의 컬럼을 조합하여 생성
    
    ex) 이름 + 생년월일
    
- **유니크 인덱스**
    
    중복을 허용하지 않는 인덱스
    
    → 유니크 인덱스 스캔에 활용
    
    ex) 휴대폰 번호, 주민등록번호
    

## 인덱스 생성

```sql
-- 단일 컬럼 인덱스
CREATE INDEX IDX_CUSTOMER_NAME ON CUSTOMERS(NAME);

-- 결합 인덱스
CREATE INDEX IDX_ORDER_CUSTOMER_DATE ON ORDERS(CUSTOMER_ID, ORDER_DATE);

-- 유니크 인덱스
CREATE UNIQUE INDEX IDX_EMAIL ON USERS(EMAIL);
```

## SQL문 실행 경로

1. SYNTAX 체크
2. 권한 체크
3. SHARED POOL 탐색
    
    있으면 EXCUTION (SOFT PARSING)
    
    없으면 OPTIMIZATION (HARD PARSING)
    

## 인덱스 관리 팁

- 자주 사용되는 컬럼에 생성
    
    WHERE, JOIN, ORDER BY, GROUP BY에 자주 등장하는 컬럼
    
    +SELECT절 
    
- 적절한 인덱스 개수 유지
- 쓰기와 읽기 비율 고려
    
    읽기 작업에 많은 테이블에 적합
    
- 데이터 중복도 파악
    - 중복도가 낮은 컬럼은 B-Tree
    - 중복도가 높은 컬럼은 Bitmap 인덱스 (잘 사용하지 않음)

## 인덱스 스캔

- Index Range Scan
    
    인덱스 스캔 범위 줄이기
    
    테이블 액세스 빈도 줄이기
    
    범위 조건, 조건에 맞는 많은 데이터를 찾을 때 사용
    

## 인덱스 설계 시 유의사항

- **인덱스 커럶의 순서**
    
    결합 인덱스에서 SELECT 조건에 자주 사용되는 컬럼을 우선적으로 배치
    
- **쓰기 작업 최적화**
    
    데이터 변경 작업이 빈번한 테이블은 최소한의 인덱스를 유지
    
- **카디널리티**
    
    고유도가 높은 컬럼에 인덱스를 설정
    
- **데이터 크기와 접근 빈도**
    
    대용량 데이터 테이블에서 인덱스는 필수
    

## 인덱스를 타지 못한다는 것의 의미

- 인덱스가 있음에도 SQL쿼리가 인덱스를 활용하지 않고 테이블 전체를 스캔하는 것.

→ 불필요한 데이터 검색으로 인해 성능 저하 발생

## 인덱스를 활용하지 못하게 하는 주요 원인

- 인덱스 컬럼에 함수, 연산 사용
    
    시작점을 찾을 수 없어서 FULL SCAN 하게 됨
    
    - FBI: Function Based Index
    - Reverse Key Index
        
        날짜와 같은 순차적으로 증가하는 값이 입력될 때 특정 index block에 과도한 경합이 발생하는 것을 방지
        
        → equal 검색만 가능 
        
    - Clustered Index
        
        인덱스 순서에 따라 물리적으로 구분
        
    - IOT: Index Organized Table
        
        테이블의 데이터를 B-Tree 인덱스에 저장
        
        PK검색이 매우 빠르지만 그 외의 값으로 검색은 느림
        
    
    ```sql
    SELECT * FROM EMPLOYEES WHERE ROUND(SALARY) = 5000;
    
    SELECT * FROM EMPLOYEES WHERE SALARY BETWEEN 4999.5 AND 5000.5;
    ```
    
- 데이터 타입 불일치
    
    ```sql
    SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = '101';
    
    SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 101;
    ```
    
- 와일드카드(%) 사용 위치
    
    와일드카드가 앞에 있으면 인덱스 활용이 어려워짐
    
    ```sql
    SELECT * FROM CUSTOMERS WHERE NAME LIKE '%JOHN%';
    
    SELECT * FROM CUSTOMERS WHERE NAME LIKE 'JOHN%';
    ```
    
- NULL 값 처리
    
    ```sql
    SELECT * FROM EMPLOYEES WHERE SALARY IS NULL;
    
    ALTER TABLE EMPLOYEES MODIFY SALARY DEFAULT 0;
    ```
    
- OR 조건이 포함된 경우
    
    많은 경우 OR EXPANSION으로 처리됨
    
    ```sql
    SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 10 
    	OR MANAGER_ID = 5;
    
    SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 10
    UNION ALL
    SELECT * FROM EMPLOYEES WHERE MANAGER_ID = 5;
    ```
    

# SQL 실습 문제

```sql
-- 실습 1번
-- 지점별 승인된 대출의 총 금액이 전체 지점에서 승인된 대출 금액의 평균보다 낮은 지점
-- 지점명, 지점별 총 대출 금액, 전체 평균 출력
SELECT *
FROM (
    SELECT (SELECT NAME FROM BRANCHES WHERE L.BRANCH_ID = BRANCH_ID) 지점명, 
        SUM(AMOUNT) OVER (PARTITION BY BRANCH_ID) "지점별 총 대출 금액",
        ROUND(AVG(AMOUNT) OVER (), 2) "전체 대출 평균"
    FROM LOANS L
    WHERE STATUS = 'APPROVED'
    )
WHERE "지점별 총 대출 금액" < "전체 대출 평균";

-- 실습 2번
-- 모든 직원의 사번, 이름, 상사의 이름, 상사의 부서 출력
-- 없으면 'NO MANAGER', 'NO DEPARTMENT' 출력
SELECT 사번, 이름,
    NVL("상사의 이름", 'NO MANAGER') "상사 이름",
    NVL((SELECT DEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = "상사의 부서 ID"), 'NO DEPARTMENT') "상사 부서"
FROM (
    SELECT EMPLOYEE_ID 사번, NAME 이름, 
        (SELECT NAME FROM EMPLOYEES WHERE E1.MANAGER_ID = EMPLOYEE_ID) "상사의 이름",
        (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE E1.MANAGER_ID = EMPLOYEE_ID) "상사의 부서 ID"
    FROM EMPLOYEES E1);
-- -> SELF JOIN으로 해보기
SELECT E.EMPLOYEE_ID 사번,
    E.NAME 이름,
    NVL(M.NAME, 'NO MANAGER') "상사 이름",
    NVL(D.DEPARTMENT_NAME, 'NO DEPARTMENT') "상사 부서"
FROM EMPLOYEES E
    LEFT JOIN EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID
    LEFT JOIN DEPARTMENTS D ON M.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 실습 3번
-- 사번, 이름, 급여, 백분율 순서대로 출력
SELECT EMPLOYEE_ID 사번, SALARY 급여,
    ROUND(SALARY / SUM(SALARY) OVER () * 100, 2) 백분율
FROM EMPLOYEES
WHERE SALARY IS NOT NULL
ORDER BY 백분율 DESC;

-- 실습 4번
-- 각 계좌의 최고 거래 금액이 높은 순으로 상위 5위까지의 계좌 출력
SELECT * FROM (
    SELECT ACCOUNT_ID "계좌 ID", MAX(BALANCE) "최고 거래금액",
        DENSE_RANK() OVER (ORDER BY MAX(BALANCE) DESC) 순위
    FROM ACCOUNTS
    GROUP BY ACCOUNT_ID)
WHERE 순위 <= 5;

-- 실습 5번
-- 각 부서에서 급여가 가장 높은 직원과 가장 낮은 직원의 급여 차이를 계한하여 출력
SELECT DEPARTMENT_ID "부서 ID", MAX(SALARY) - MIN(SALARY) "최대, 최소 급여 차이"
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
ORDER BY "부서 ID";

-- 실습 6번
-- 사번, 이름, 급여, 부서 평균 급여, 차이를 출력
SELECT EMPLOYEE_ID 사번, NAME 이름, SALARY 급여, "부서별 평균 급여", SALARY - "부서별 평균 급여" "급여의 차이"
FROM EMPLOYEES E
    LEFT JOIN (
        SELECT DEPARTMENT_ID, ROUND(AVG(SALARY), 2) "부서별 평균 급여"
        FROM EMPLOYEES
        WHERE DEPARTMENT_ID IS NOT NULL
        GROUP BY DEPARTMENT_ID) T
    ON E.DEPARTMENT_ID = T.DEPARTMENT_ID;

SELECT EMPLOYEE_ID 사번, NAME 이름, SALARY 급여,
    ROUND(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID), 2) "부서별 평균 급여",
    SALARY - ROUND(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID), 2) "급여의 차이"
FROM EMPLOYEES;

-- 실습 7번
-- 이름이 'Employee 241'인 사우너의 모든 상사를 한 줄로 출력
SELECT *
FROM (
    SELECT LTRIM(SYS_CONNECT_BY_PATH(NAME, ' > '), ' > ') "모든 상사들"
    FROM EMPLOYEES
    START WITH NAME = 'Employee 241'
    CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID
    ORDER BY LEVEL DESC)
WHERE ROWNUM = 1;
-- 강사님 쿼리문
SELECT MAX(LTRIM(SYS_CONNECT_BY_PATH(NAME, ' > '), ' > ')) "모든 상사들"
FROM EMPLOYEES
START WITH NAME = 'Employee 241'
CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID;

-- 실습 8번
-- 급여가 높은 상위 10명의 사원 정보 출력
-- 급여가 동일한 경우 사원 이름 순으로 정렬
SELECT * FROM (
    SELECT *
    FROM EMPLOYEES
    WHERE SALARY IS NOT NULL
    ORDER BY SALARY DESC, NAME)
WHERE ROWNUM <= 10;

-- 실습 9번
-- 입사 연도별 급여 합계를 출력
-- 가장 아랫줄에 'ALL YEARS'로 전체 급여 합계 출력
SELECT NVL(TO_CHAR(HIRE_DATE, 'YYYY'), 'ALL YEARS') "입사 연도", SUM(SALARY) "급여 합계"
FROM EMPLOYEES
WHERE HIRE_DATE IS NOT NULL -- 만약 HIRE_DATE = NULL 인 데이터는 따로 뽑아야 하면 GROUPING 사용해서 구분하기
GROUP BY ROLLUP(TO_CHAR(HIRE_DATE, 'YYYY'))
ORDER BY "입사 연도";

-- 실습 10번
-- 부서별, 직무별, 전체 급여 합계를 출력
SELECT (SELECT DEPARTMENT_NAME FROM DEPARTMENTS WHERE E.DEPARTMENT_ID = DEPARTMENT_ID) 부서명, 
    JOB_ID "직무 ID", SUM(SALARY) "급여 합계"
FROM EMPLOYEES E
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(DEPARTMENT_ID, JOB_ID, ())
ORDER BY DEPARTMENT_ID, JOB_ID;

-- 실습 11번
-- 부서 ID, 사원 이름, 급여, -100 ~ +100 급여 합계
SELECT DEPARTMENT_ID "부서 ID", NAME 사원이름, SALARY 급여,
    SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID
        ORDER BY SALARY
        RANGE BETWEEN 100 PRECEDING AND 100 FOLLOWING) "계산된 급여"
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID;

-- 실습 12번
--  사번, 급여, 직무 평균과 비교, 전체 평균과 비교 출력
SELECT 사번, 급여, 
    CASE
        WHEN 급여 >= "직무 평균 급여" THEN '직무 평균 이상'
        ELSE '직무 평균 이하'
    END "직무 평균 급여 비교",
    CASE
        WHEN 급여 >= "전체 평균 급여" THEN '전체 평균 이상'
        ELSE '전체 평균 이하'
    END "전체 평균 급여 비교"
FROM (
    SELECT
        EMPLOYEE_ID 사번, 
        SALARY 급여,
        AVG(SALARY) OVER (PARTITION BY JOB_ID) "직무 평균 급여",
        AVG(SALARY) OVER () "전체 평균 급여"
    FROM EMPLOYEES);

```
