# Java 언어 특징

## 같은 코드를 여러 플랫폼에 적용시킬 수 있다.

컴파일러가 우리가 작성한 코드를 기계어로 변경하여 실행하게 됨

- 하이레벨 언어로 작성한 코드를 컴파일러를 통해서 머신코드로 변경
- Java는 머신코드로 바꾸지 않고, 컴파일러를 통해서 **바이트코드**로 변경한다. (다른 언어들과의 차이점)
- 바이트코드 = 중간 형태
- 바이트코드를 읽어서 실행할 수 있는 프로그램 = **JVM**
- JVM이 바이트코드를 읽어들여서 머신코드로 변경한다.
- (장점) 따라서 JVM만 있으면 어떤 환경이라도 실행될 수 있다.
- (단점) 속도가 느리다. → 최근에는 많이 개선됨
- .java 확장자 → javac compiler → .class (바이트코드) → JVM가 실행

## Java는 객체지향 언어이다.

언어의 구분

- **절차적 언어**
    
    C언어: 프로그램의 기본 단위가 함수이다.
    
    프로그램을 만드는 기준: **기능**
    
    기능으로 프로그램을 세분화한다.
    
    → 더 이상 분할 할 수 없는 단위 기능이 나오게 된다. (함수로 구현)
    
    - 장점
        
        요구사항 분석이 쉽다.
        
        설계와 구현이 쉽다.
        
        → 비용 절감
        
    - 단점
        
        유지보수가 어렵다.
        
        정보량이 증가하면서 변화가 많아짐
        
- **객체지향 언어**
    
    절차적 언어의 문제를 해결하기 위한 프로그램의 패러다임 변화로 등장
    
    현실 세계의 요소들을 그대로 프로그래밍으로 구현 → **모델링**
    
    프로그램을 만드는 기준: **구성 요소, 상호 작용**
    
    설계가 사람에 따라 달라지고, 좋은 설계와 안 좋은 설계가 나옴
    
    **설계에 시간을 많이 쓰게 된다.**
    
    - 장점
        
        유지보수가 편하다. → 비용 절감
        
    - 단점
        
        제대로 설계를 하기가 어렵다.
        

자바는 객체지향 개념을 가장 잘 프로그래밍에 반영한 언어라는 평을 받는다.

## JVM

Java Virtual Machine

JVM이 있어야 우리가 작성한 코드를 실행할 수 있다.

bytecode를 읽어들여서 프로그램을 실행시키는 주체이다.

## JRE

Java Runtime Environment (자바실행환경)

JVM을 포함하는 여러가지 라이브러리들을 합쳐놓은 개념

→ JVM + Java Class Library

## JDK

Java Development Kit (자바개발도구)

JRE를 포함, 실제로 실행시켜줄 수 있는 여러 도구들

직접적으로 개발을 할 때 필요 (IDE는 제외)

→ JRE + 자바개발도구(javac, java, javadoc, etc…)

## Java의 객체지향

객체지향: 현실세계의 구현해야 하는 문제를 프로그래밍적으로 표현 (모델링)하는 구현 방식

- 해결해야 하는 문제를 구성하고 있는 구성요소를 파악
- 구성요소를 파악한 후 프로그램으로 표현해야 한다.
- 필요한 기능만 **추상화(abstraction)**하여 간단하게 표현한다.
    - 상태: 데이터
        
        ex) 잔액, 나이, 주소, …
        
        → 변수 = **필드(field)**
        
    - 행위: 동작
        
        ex) 입금, 출금, 대출, …
        
        → 함수 = **메소드(method)**
        
    
    → 필드와 메소드를 포함하는 한 단위 = **클래스(class)**
    
    = 객체 모델링의 수단
    

## 1) class는 **객체 모델링을 하기 위한 수단**으로 사용한다.

- 결국 자바프로그램은 클래스의 집합으로 표현될 수 있다.
- 일반적으로 파일 하나에 클래스 하나를 매핑한다.
- 클래스의 이름 = 파일이름으로 명명 (public class인 경우에만)
- 클래스의 이름은 대문자로 시작한다.

```java
// 클래스의 이름은 첫글자 대문자로 써야 한다.
class Customer {
	// fields
	String name; // 고객이름
	int age;     // 고객나이
	// methods

}
```

## 2) class라는 단위는 ADT이다.

클래스는 묘사하는 단위이고, 이로부터 저장공간을 생성해서 그 저장공간으로 프로그래밍을 진행한다.

→ 이 저장공간을 **instance(객체)**라고 한다.

클래스는 내가 임의로 만들 수 있는 데이터 타입이다.

= **추상 테이터 타입** = **Abstract Data Type (ADT)**

## 3) class는 instance를 파생시키는 수단이다.

따라서 하나의 프로그램에는 상당히 많은 class들이 존재한다.

→ 동일한 기능의 class들을 **package**로 관리한다.

= 패키지 이름의 폴더로 표현된다.

모든 class는 package 안에 들어간다.

- unnamed package
    
    이름이 없는 패키지 → 거의 사용하지 않음
    

```java
package mypackage.com;

public class Customer {
    // fields
    // 변수들

    // 생성자(constructor)
    // instance 를 생성하기 위해서 필요

    // methods
    // 함수들
    public static void main(String[] args) {
        System.out.println("이것은 소리없는 아우성!!");
    }

}
```

# Data Type

- 언어의 데이터 타입 표기 종류
    - strong type language
        
        변수의 타입을 명확히 선언하는 언어
        
    - weak type language
        
        변수의 타입을 명시하지 않아도 됨
        
    
    → Java는 강타입 언어이다.
    
- java는 대소문자 구분을 하고, 변수길이에 제한이 없다.
- 예약어로는 변수를 만들 수 없다.
- 숫자로 시작하는 변수는 만들 수 없다.
- 특수문자는 ‘_’와 ‘$’만 허용된다.
- 네이밍 (권장)
    - 클래스 이름은 pascal case (첫 글자 대문자)
        
        MyFriend
        
    - 일반변수 이름은 camel case (구분 대문자)
        
        myFriend
        
- java의 데이터타입은 크게 두 가지로 나뉜다.
    - **primitive data type** (8개)
        
        해당 타입으로 선언된 변수 안에 직접 데이터가 저장
        
        문제) 프리미티브 데이터 타입은 스택에 저장된다. → X
        
        정수형
        
        - byte (1)
        - short (2)
        - int (4)
            
            → 기본으로 사용됨 (계산은 int로 되기 때문에 가장 효율적이다)
            
        - long (8)
        
        실수형
        
        - float
        - double → 기본으로 사용
        
        문자형
        
        - char (unicode라서 숫자처럼 연산이 가능하다)
        
        논리형
        
        - boolean
    - **reference data type** (class를 데이터 타입으로 사용할 때)
        
        메모리 주소값에 대한 hash값을 갖고 있다. (직접적인 주소는 위험때문에 막아놓는다.)
        

## JVM 메모리 구조

1. **Method Area** 
    - 공간이 아니라 클래스에 대한 정보가 들어간다.
    - 실행할 때는 main()이 있는지 확인을 한다.
2. **Stack**
    - main()에서 필요한 지역변수, 매개변수들이 할당된다.
    - main()이 끝나면 할당된 영역이 해제된다.
        
        → method area에 있는 클래스에 대한 정보도 해제된다.
        
3. **Heap**
    - new 키워드로 reference data를 생성하면, 생성자를 호출하여 그에 해당하는 데이터를 할당한다.
    - 해당 데이터를 가리키는 reference data가 사라지면, java의 garbage collector가 자동으로 해당 데이터를 해제시켜준다.

## 상수

`final` 키워드 → 상수를 표현

- 보통 snake 형식으로 명명한다.
    
    ```java
    final int MY_AGE = 20;
    ```
    

## 형변환

하나의 데이터 타입이 다른 데이터 타입으로 변환하는걸 의미

1. **묵시적 형변환 (implicit)**
    
    자동적으로 변환되는 것.
    
    안전한 경우에 바뀐다.
    
    → 크게 신경 쓸 필요 없음
    
2. **명시적 형변환 (casting)**
    
    임의로 데이터 형식을 바꾸는 것.
    
    괄호를 사용
    

# 객체지향

자바는 전역변수 개념이 없다.

- `static` 키워드 → 인스턴스 없이 사용이 가능하게 하는 키워드
    
    static이 붙은 변수는 method area에 공간이 만들어지며, 값이 저장된다.
    
- `this` → 쓰인 영역이 가리키는 레퍼런스

## Overloading

: 같은 이름이나 같은 형태로 여러개의 기능을 수행하는 경우

- 연산자 오버로딩
- 메소드 오버로딩
- 생성자 오버로딩

```java
package mypackage;

public class InstanceTest {
    // static field 또는 static variable 또는 class variable
    static int a = staticCall("1번");
    // instance variable
    int b = staticCall("2번");

    // static method
    static public int staticCall(String msg){
        System.out.println(msg);
        return 100;
    }
    // 생성자
    // 기본생성자는 무조건 작성을 하는게 좋다.
    // 생성자는 인스턴스를 생성하기 위해서 반드시 호출되고, 만들어진 인스턴스를 초기화하는 역할을 한다.
    public InstanceTest() {
        this.b = staticCall("3번");
    }
    // 생성자 오버로딩
    public InstanceTest(int b){

    }

    // entry point
    public static void main(String[] args) {
        System.out.println("4번");
        int c = staticCall("5번");
        InstanceTest d = new InstanceTest();
    }
}
```
