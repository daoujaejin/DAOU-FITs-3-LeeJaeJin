# JavaFX

GUI를 만들기 위한 Java API

→ 실무보다는 JDBC, MVC Pattern을 공부할 때 좋다.

- 설정

클래스 파일 → 실행 외 디버그 → 실행 구성 수정 → 옵션 수정 → VM옵션 추가 → 코드 추가 (경로 수정)

```java
--module-path "C:\Users\daou__jaejin\Downloads\openjfx-17.0.14_windows-x64_bin-sdk\javafx-sdk-17.0.14\lib" --add-modules javafx.controls,javafx.fxml
```

## 구성

- Stage
    
    나오는 전체 창
    
- Scene
    
    stage 위에 붙는 장면
    
- Layout Manager
    
    Scene에 들어가는 components들을 관리하는 개념
    

```java
public class Main extends Application {
    @Override
    public void start(Stage stage) throws Exception {
        // 화면 구성과 이벤트 처리에 대한 코드가 나와요!
        Button btn = new Button();
        btn.setText("클릭 클릭");

        // Layout Manager에 버튼을 부착해야 한다.
        StackPane root = new StackPane();
        root.getChildren().add(btn);

        // Scene 만들기
        Scene scene = new Scene(root, 300, 200);

        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```

## Event Delegation Model

1. **event source**
    
    event 발생 객체
    
2. **event 객체 (자동생성)**
    
    event 세부정보를 담고 있음
    
    → event 처리 객체로 이동
    
3. **event 처리 객체 (handler)**
    
    method가 처리를 한다.
    
    interface로 구성되어 있다.
    

```java
public class Main extends Application {
    @Override
    public void start(Stage stage) throws Exception {
        // 화면 구성과 이벤트 처리에 대한 코드가 나와요!
        Button btn = new Button();
        btn.setText("클릭 클릭");

        // Button이 Event source가 된다.
        // Handler가 있어야 Event가 발생했을 때 처리가 가능하다.
        // mouse 클릭 이벤트 (action event)
        // EventHandler ev = new EventHandler() {
        //     public void handle(Event event) {
        //         // event 처리 할 때 자동으로 호출
        //         System.out.println("버튼이 클릭 클릭");
        //     }
        // };
        
        btn.setOnAction(
            (ActionEvent event) -> {
                // event 처리 할 때 자동으로 호출
                System.out.println("버튼이 클릭 클릭");
            }
        );

        btn.setOnAction(ev);

        // Layout Manager에 버튼을 부착해야 한다.
        StackPane root = new StackPane();
        root.getChildren().add(btn);

        // Scene 만들기
        Scene scene = new Scene(root, 300, 200);

        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```

## JavaFx Scene Builder

따로 화면을 구성하고, `.xml` 파일을 불러와서 화면을 구성한다.

# VO

- **VO**
    
    Value Object → table에 집중
    
    각 table의 하나의 row를 담을 수 있는 객체
    
    (모든 컬럼 값을 갖고있지 않아도 된다.)
    
    값을 처리하지 않기 때문에 logic 처리가 들어가면 안된다.
    
- **DO**
    
    Domain Object → 광범위
    
    Domain에서 사용하는 데이터를 객체화시킨 것
    
- **Entity**
    
    VO와 유사 → Primary Key를 반드시 포함
    
- **DTO**
    
    Data Transfer Object
    
    VO를 데이터를 다른 곳으로 전송하는 관점에서 보는 것
    

# Layered Architecture

일반적으로 4계층

- 인접한 계층간에만 연결된다.
- 각 계층은 캡슐화 되어 있고, 단일 책임을 갖는다.

→ 구체적인 프로그래밍 패턴이 파생된다.

ex) MVC 패턴

## 1. Presentation Layer

입출력 처리

전체 프로그램 중에 사용자와 대면하는 부분

logic 처리 없음

## 2. Business (Logic) Layer

조직 처리

입력을 받아서 Logic 처리를 함

## 3. Persistence Layer

DB 접근

## 4. Database Layer

실제 DB

Oracle, MySQL, …

# MVC Pattern

Model-View-Controller 디자인 패턴

## Model

- Data Model
    
    VO
    
- Service Model
    
    로직 처리 전담 객체
    
    - 순수로직처리
    - DB처리는 구분하고, Service Model에서 하면 안된다.
        
        → DAO (Data Access Object)
        

## View

입출력 담당 (Presentation Layer)

java에서 stage

## Controller

View에서 입력을 받아서 어떤 Model의 서비스와 연결할 것인지 제어

(Model과 View 사이의 bridge 역할 수행)
