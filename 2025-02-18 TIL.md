# 복습

- **Client**
    
    Web Browser
    
    → Server에 HTTP request(문자열)를 보낸다.
    
    HTML resource를 받은 뒤 :
    
    1. HTML의 내용 DOM 구조 생성
    2. css의 내용으로 css object model 생성
    3. 위의 내용을 기반으로 Render Tree 생성 → 화면에 그림을 그린다.
    
- **Server**
    
    Tomcat → Web Server + WAS
    
    - HTTP server : http request를 받음 (8080 포트)
    - WAS : application을 실행해줌
    - 여러 project들 : application context로 구분한다.
    
    → 정적 resource로 처리 가능한 요청은 HTTP Server에서 처리한다.
    
    HTML resource 보낸다.
    
    → 실행해야 하는 경우 : HTTP Request를 WAS로 전달.
    
    1. 해당 instance 있는지 확인
    2. project(Servlet)를 활용해 instance 생성
        
        Servelet instance에서 `init()` 호출
        
    3. Thread Invoker가 Client의 요청을 처리하는 thread를 만든다.
        
        thread가 servlet instance의 `service()` 호출
        
        HTTP Request를 `HttpServletRequest` 객체로 만든다.
        
        +`HTTPServletResponse` 도 만들어서 `service()` 호출
        
        → service()에서 `doGet()` 이나 `doPost()` 호출
        
    4. thread는 할 일을 다하면 소멸되지만, 
        
        servlet instance는 계속 존재한다.
        
        → 다음부터 같은 instance가 나오면 thread만 만들어서 사용한다.
        
        = `Singletono Pattern`
        

# Client 식별

HTTP Protocol은 `Stateless Protocol (무상태 프로토콜)` 특징이 있다.

= 서버는 클라이언트가 이전에 어떤 요청을 했는지 알 수 없는 특징이 있다.

→ 이 사람이 로그인을 했는지, 안했는지 알 수가 없다.

(Server는 기본적으로 Client를 구분할 수 없다.)

## 1. Cookie

**문자열**을 이용 (서버에서 클라이언트에 박아놓는 징표)

ex) name=홍길동;age=20 + 유효기간, 유효 Domain

→ **Client Web Browser에 저장**

1. doPost(), doGet()에서 cookie 문자열 생성
2. response 객체를 이용해 cookie 설정
3. 심어둔 cookie는 browser 내에 저장
4. +) 그 뒤에 요청을 하는 domain과 cookie의 domain이 일치한다면 자동으로 쿠키가 같이 보내진다.

단점: 

- 쿠키가 client에 저장되서 보안성이 없다.
    
    → 민감한 정보는 저장할 수 없다.
    
- 문자열이기 때문에 처리가 쉽지 않다.

쿠키의 한계 극복 → session

## 2. Session

Session은 객체이다.

**HttpSession class의 instance → WAS 안에 저장**

→ Cookie를 이용한다. (url을 이용해도 된다)

1. client에 sessionID 정보에 관한 cookie를 보내놓음
    
    → 하나의 클라이언트에 하나의 세션이 만들어짐 (세션에 sessionID 부여됨)
    
2. doGet()이 호출될 때 session을 요청
3. 쿠키의 sessionID와 맞는 session을 참조하여 활용 (로그인 했는지 유무)

단점:

- sessionID 쿠키를 지우면 session을 찾을 수 없다.

# JSP

Servlet은 Java 코드 안에 HTML코드를 포함해야 해서 출력이 어렵다.

→ `JSP` 를 통해 HTML 안에 Java 코드를 넣어서 표현해서 출력을 쉽게 한다.

→ Translation으로 자동화

servlet의 결과 화면이

- 정적 화면
    
    → 결과 정적 파일의 URL을 알려준다. (정적 HTML)
    
- 동적 화면
    
    → 결과를 출력하는 변경 가능한 HTML = JSP
    
    → View의 역할
    
    JSP에 데이터를 넣어서 client에게 전달한다.
    
    `requestDispatcher` : 한 servlet이 다른 servlet을 호출할 수 있도록 하는 class
    
    `forward()` : 다음 servlet에서 결과를 받아갈 수 있도록 하는 method
    

## web 반환 변화 (Round Trip 방식)

1. static web
2. Dynamic web
    
    WAS에서 돌아가는 Servlet이 등장
    
    → 동적 content 생성
    
    출력이 불편
    
3. JSP 파일로 출력
    
    유지보수가 힘들다.
    
4. MVC 패턴으로 유지보수 강화
    
    Servlet을 다시 사용 → controller
    
    JSP → view
