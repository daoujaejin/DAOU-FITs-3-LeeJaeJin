# 서브쿼리

- SQL문 안에 포함된 또 다른 SQL문
- 많이 사용하면 가독성을 해칠 수 있다.

## 서브쿼리 분류

- 연관 여부: 메인쿼리와 연관 유무
    
    비연관 서브쿼리, 연관 서브쿼리
    
- 위치에 따른 분류
    
    스칼라 서브쿼리, 인라인 뷰, 중첩 서브쿼리
    
- 반환값 유형에 따른 분류
    
    단일 행 서브쿼리, 다중행 서브쿼리, 다중열 서브쿼리
    

# 연관 여부에 따른 분류

## 비연관 서브쿼리

- 서브쿼리가 독립적으로 실행되어 결과를 반환
- 메인쿼리와 서브쿼리 간 상호작용 없음
- 서브쿼리만으로 실행 가능

```sql
-- 비연관 서브쿼리
SELECT NAME
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES);
```

## 연관 서브쿼리

- 서브쿼리가 메인 쿼리의 각 행마다 실행
- 메인쿼리의 데이터를 서브쿼리에서 참조

```sql
-- 연관 서브쿼리
SELECT NAME FROM EMPLOYEES E1
WHERE SALARY = (
    SELECT MAX(SALARY)
    FROM EMPLOYEES E2
    WHERE E1.DEPARTMENT_ID = E2.DEPARTMENT_ID);
```

# 위치에 따른 분류

## 스칼라 서브쿼리

- 서브쿼리가 컬럼 값으로 반환되어 **SELECT절**에서 사용
- 주로 집계 값이나 계산 결과를 포함할 때 활용
- 캐싱 기능이 있다. (같은 결과는 캐시로 저장되어 참조한다.)
    
    → 서브쿼리와 JOIN의 성능차이는 대부분의 경우 많이 나지 않는다.
    

```sql
-- 스칼라 서브쿼리
SELECT NAME, SALARY,
    (SELECT AVG(SALARY) FROM EMPLOYEES
    WHERE DEPARTMENT_ID = E.DEPARTMENT_ID) AS
    AVG_SALARY
FROM EMPLOYEES E;
```

## 인라인 뷰

- **FROM절**에서 서브쿼리 결과를 테이블처럼 사용
- 별칭을 붙여 활용 가능

```sql
-- 인라인 뷰
SELECT D.DEPARTMENT_NAME, T.AVG_SALARY
FROM DEPARTMENTS D,
    (SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY
    FROM EMPLOYEES GROUP BY DEPARTMENT_ID) T
WHERE D.DEPARTMENT_ID = T.DEPARTMENT_ID;
```

## 중첩 서브쿼리 (WHERE)

- **WHERE절**에서 조건을 설정하기 위해 사용
- 가장 많이 사용하게 된다.

```sql
-- 중첩 서브쿼리
SELECT NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE DEPARTMENT_NAME = 'Department 1');
```

## 중첩 서브쿼리 (HAVING)

- **HAVING절**에서 조건을 설정하기 위해 **집계 함수**와 함께 사용

```sql
-- 중첩 서브쿼리
SELECT DEPARTMENT_ID, SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) > (SELECT AVG(SUM(SALARY))
                        FROM EMPLOYEES
                        GROUP BY DEPARTMENT_ID);
```

# 반환값 유형에 따른 분류

## 단일 행 서브쿼리

- 서브쿼리가 **단일 행**과 **단일 열**을 반환
- 비교 연산자와 함께 사용
- 스칼라 서브쿼리는 단일 열 서브쿼리이다.

```sql
-- 단일 행 서브쿼리
SELECT NAME
FROM EMPLOYEES
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEES);
```

## 다중 행 서브쿼리

- 서브쿼리가 여러 행을 반환
- 다중 행 연산자 (IN, ANY, ALL)과 함께 사용

```sql
-- 다중 행 서브쿼리
SELECT NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE LOCATION = 'New York');
```

## 다중 열 서브쿼리

- 서브쿼리가 여러 열을 반환
- 메인 쿼리의 여러 열과 비교 가능

```sql
-- 다중 열 서브쿼리
SELECT NAME
FROM EMPLOYEES
WHERE (DEPARTMENT_ID, JOB_ID) IN (
			SELECT DEPARTMENT_ID, JOB_ID
			FROM JOB_HISTORY);
```

# 서브쿼리 사용 시 유의사항

- **성능 최적화**
    
    비연관 서브쿼리는 독립적으로 실행되므로 더 빠르다.
    
    연관 서브쿼리는 메인 쿼리의 각 행마다 실행되므로 성능 저하 가능
    
- **적절한 반환값 확인**
    
    서브쿼리가 반환하는 값의 유형(단일 값, 다중 값)에 따라 연산자 선택이 중요
    
- **JOIN 대체 가능성**
    
    그때 그때 다르다.
    
- 불필요하게 같은 테이블을 중복조회하는 서브쿼리는 좋지 않다.

## 서브쿼리 예제

```sql
-- 가장 많은 잔액을 가진 계좌의 잔액, 계좌 ID
SELECT ACCOUNT_ID, BALANCE
FROM ACCOUNTS
WHERE BALANCE = (SELECT MAX(BALANCE) FROM ACCOUNTS);

-- 가장 최근에 가입한 고객의 이름과 날짜 조회
SELECT NAME, CREATED_AT
FROM CUSTOMERS
WHERE CREATED_AT = (SELECT MAX(CREATED_AT) FROM CUSTOMERS);

-- 잔액이 평균 잔액보다 높은 계좌를 조회
SELECT ACCOUNT_ID, BALANCE
FROM ACCOUNTS
WHERE BALANCE > (SELECT AVG(BALANCE) FROM ACCOUNTS);

-- 각 지점에서 대출 금액이 가장 높은 대출을 조회
SELECT BRANCH_ID, LOAN_ID, AMOUNT
FROM LOANS L1
WHERE AMOUNT = (
    SELECT MAX(AMOUNT)
    FROM LOANS L2
    WHERE L1.BRANCH_ID = L2.BRANCH_ID);
    
-- 각 계좌의 거래 중에서 가장 큰 거래 금액을 조회
SELECT ACCOUNT_ID, TRANSACTION_ID, AMOUNT
FROM TRANSACTIONS T1
WHERE AMOUNT = (
    SELECT MAX(AMOUNT)
    FROM TRANSACTIONS T2
    WHERE T1.ACCOUNT_ID = T2.ACCOUNT_ID);
```

# 집합연산자

- SQL에서 두 개 이상의 SELECT 결과를 결합하여 하나의 결과 집합을 생성
- 집합 이론을 기반으로 작동
- UNION ALL을 제외한 다른 집합연산자는 모두 중복을 제거한다.

## UNION

- 두 SELECT 결과를 합친 귀 중복된 행은 제거
- 결과는 정렬된 상태로 반환
- 문법
    
    ```sql
    SELECT 컬럼명 FROM 테이블1
    UNION
    SELECT 컬럼명 FROM 테이블2;
    ```
    
- ALIAS를 사용할 때는 첫 번째 테이블의 이름으로 된다.
- ORDER BY는 맨 아래에 한 번만 쓸 수 있다.

## UNION ALL

- 두 SELECT 결과를 합치며 중복된 행도 포함
- 결과는 정렬되지 않음
- 문법
    
    ```sql
    SELECT 컬럼명 FROM 테이블1
    UNION ALL
    SELECT 컬럼명 FROM 테이블2;
    ```
    

## INTERSECT

- 두 SELECT 결과의 교집합 반환
- 중복된 행은 제거
- 문법
    
    ```sql
    SELECT 컬럼명 FROM 테이블1
    INTERSECT
    SELECT 컬럼명 FROM 테이블2;
    ```
    

## MINUS

- 첫 번째 SELECT 결과에서 두 번째  SELECT 결과를 제외한 차집합 반환
- 중복된 행은 제거
- 문법
    
    ```sql
    SELECT 컬럼명 FROM 테이블1
    MINUS
    SELECT 컬럼명 FROM 테이블2;
    ```
    

## 집합연산자 유의사항

- SELECT절에 나열된 컬럼 수와 데이터 타입이 동일해야 함
- 결과 집합의 순서는 기본적으로 보장되지 않음
- ORDER BY는 최종 결과에만 적용 가능
- 대량 데이터 처리 시 성능에 유의해야 함
- ALIAS는 맨 처음 SELECT절을 따름

```sql
-- CUSTOMERS와 LOANS에서 공통적으로 존재하는 고객ID 조회
SELECT CUSTOMER_ID FROM CUSTOMERS
INTERSECT
SELECT CUSTOMER_ID FROM LOANS;

-- TRANSACTIONS와 ACCOUNTS의 계좌 유형을 중복 없이 결합하여 조회
SELECT TRANSACTION_TYPE FROM TRANSACTIONS
UNION
SELECT ACCOUNT_TYPE FROM ACCOUNTS;
```

# 윈도우 함수

- SQL에서 행을 기준으로 특정 범위(Window)를 정의하여 작업하는 함수
- 윈도우 = 창문
    
    원하는 부분을 내가 정하여 작업을 할 수 있다.
    
- 집계 함수와 함께 데이터를 그룹핑하지 않고도 계산 가능

## 순위 함수

ROWNUM보다 조금 더 발전된 기능의 함수들

- **RANK**: 순위를 계산하며 동일한 값은 같은 순위를 부여 (순위 건너뜀)
    
    ```sql
    SELECT EMPLOYEE_ID, NAME, SALARY,
        RANK()OVER(PARTITION BY DEPARTMENT_ID 
            ORDER BY SALARY DESC NULLS LAST) AS rank
    FROM EMPLOYEES;
    ```
    
- **DENSE_RANK**: 순위를 계산하며 동일한 값은 같은 순위를 부여 (순위 건너뛰지 않음)
    
    ```sql
    SELECT EMPLOYEE_ID, NAME, SALARY,
        DENSE_RANK() OVER (ORDER BY SALARY DESC NULLS LAST) AS dense_rank
    FROM EMPLOYEES;
    ```
    
- **ROW_NUMBER**: 순위를 고유하게 매김 (중복 없음)
    
    ```sql
    SELECT EMPLOYEE_ID, NAME, SALARY,
        ROW_NUMBER() OVER (ORDER BY SALARY DESC NULLS LAST) AS row_number
    FROM EMPLOYEES;
    ```
    

## 윈도우 집계 함수 기본 문법

```sql
SELECT 컬럼명,
	집계함수() OVER (PARTITION BY 컬럼
		ORDER BY 컬럼 ASC) AS 결과컬럼
FROM 테이블명;
```

- **SUM** 함수
    
    ```sql
    SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY)
    	    AS DEPT_TOTAL
    FROM EMPLOYEES;
    ```
    
- **AVG** 함수
    
    ```sql
    SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        AVG(SALARY) OVER
        (PARTITION BY DEPARTMENT_ID) AS DEPT_AVG
    FROM EMPLOYEES;
    ```
    
- **MAX** 함수
    
    ```sql
    SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        MAX(SALARY) OVER
        (PARTITION BY DEPARTMENT_ID) AS DEPT_MAX
    FROM EMPLOYEES;
    ```
    
- **MIN** 함수
    
    ```sql
    SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        MIN(SALARY) OVER
        (PARTITION BY DEPARTMENT_ID) AS DEPT_MIN
    FROM EMPLOYEES;
    ```
    
- **COUNT** 함수
    
    ```sql
    SELECT EMPLOYEE_ID, DEPARTMENT_ID,
        COUNT(EMPLOYEE_ID) OVER
        (PARTITION BY DEPARTMENT_ID) AS
            DEPT_COUNT
    FROM EMPLOYEES;
    ```
    

## PARTITION BY와 ORDER BY

- **PARTITION BY**
    
    데이터를 특정 그룹으로 나눔
    
    그룹별로 윈도우 함수가 작동
    
- **ORDER BY**
    
    데이터를 정렬하여 윈도우 함수의 동작 순서를 지정
    
    누적 계산에 주로 이용
    

## 윈도우 함수 옵션

- 윈도우 함수에서 특정 행(ROW)이나 범위(WINDOW)를 지정하는 추가 설정
- 옵션을 활용해 데이터 처리 범위를 유연하게 조정 가능
- 종류
    - ROWS
    - RANGE
    - UNBOUNDED PRECEDING
    - CURRENT ROW
    - FOLLOWING
