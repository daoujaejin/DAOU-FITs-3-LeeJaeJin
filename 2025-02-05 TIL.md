# 객체지향

## 1. class

가장 먼저 할 것 → 추상화 (Abstract)

= 객체모델링 → 객체 (Instance) 생성

## 2. instance

Instance가 의미하는 것은 heap 영역의 일정 공간이다.

## 3. constructor

new 키워드 → heap 영역에 instance 생성

constructor → 객체가 가지는 필드에 대한 초기화 작업을 주로 한다.

## 4. JVM 메모리 구조

- **Register**
    - 메모리 주소의 포인터들이 저장되는 영역
    - 개발자가 관여하지 못하는 영역)
- **Runtime Constant Pool**
    - 상수형 데이터들이 저장되는 영역
- **Method Area**
    - **class**에 대한 정보가 저장되는 영역
    - static 키워드로 잡혀 있는 데이터도 저장된다.
    - 해당 클래스를 처음 사용할 때 저장된다.
    - class가 가지는 method의 실행코드
- **Heap**
    - **Instance**들이 저장되는 영역
- Call **Stack**
    - **method**가 실행되면 생기는 메모리 영역

## 5. class member & instance member

- **class member**는 static 키워드로 선언한다.
- **static 키워드 → 필드와 메소드에 붙을 수 있다.**
    
    (지역 변수에 붙일 수 없다.)
    
    static 데이터가 많으면 코딩이 편하지만, 유지보수와 확장성을 고려하면 많이 사용하면 좋지 않다.
    
    특별한 목적이 있을 때만 (main()) 사용하는 것이 좋다.
    
    static 필드는 class명을 사용해 해당 필드를 접근할 수 있다.
    
- **instance member**는 instance가 독립적으로 확보하는 메모리 공간이다.

```java
InstanceTest d1 = new InstanceTest();
InstanceTest d1 = new InstanceTest();
// [instance member] d1.h != d2.h
// [class member] d1.k = d2.k = InstanceTest.k
```

## 6. method overloading

같은 이름의 method가 여러 개 존재하는 것을 의미

→ constructor에도 적용

## 7. package & import

- `package`
    
    소스코드를 효율적으로 관리하고 재사용하는 방법
    
    유사한 class끼리 묶어서 단위 별로 관리
    
- `import`
    
    외부 패키지에 있는 클래스를 패키지명 없이 사용 가능하다.
    

## 8. 접근제어자

클래스 앞에는 public, default만 추가할 수 있다.

- `public`
    
    패키지에 상관 없이 어디에서나 접근 가능
    
    → 외부에서 사용할 수 있도록 할 때 사용
    
- `protected`
    
    상속관계에 있는 class에서도 사용할 수 있도록 선언
    
- `default`
    
    public, protected, private가 아닌 모든 선언
    
    같은 패키지 내에서만 사용 가능
    
- `private`
    
    같은 클래스 내부에서만 접근 가능
    
    → 값에 접근하기 위해 setter, getter가 생긴다.
    
    private 키워드를 생성자에 붙이면 객체 생성이 안된다.
    
    → 싱글턴 디자인패턴에서 사용한다. (외에는 거의 사용하지 않는다)
    

```java
package aaa;
import bbb.*;

public class PackageTest {
    // instance variable
    int k;

    // default constructor (기본생성자)
    public PackageTest() {

    }

    // method
    public static void main(String args[]) {
        MyClass a = new MyClass();
        // a.balance = 200; // -> private라서 access가 안됨.
        a.setBalance(200);
    }
}
```

```java
package bbb;

// class 앞에는 access modifier가 2가지중 하나만 올 수 있다.
// public, default
public class MyClass {

    private int balance;

    // constructor
    public MyClass() {

    }

    // setter & getter
    public int getBalance() {
        return this.balance;
    }
    public void setBalance(int balance) {
        this.balance = balance;
    }

    // method
    public void printInfo() {

    }
}
```

## 9. static block

static block 안의 내용은 main thread가 호출되기 이전에 실행된다.

실제 로직이 동작하기 전 선행작업을 한다.

```java
package lecture;

class MyTest {

	int aaa;
	static int bbb = statciCall();
	
	public static int statciCall() {
		System.out.println("static method call()");
		return 100;
	}

	static {
		System.out.println("이것은 Static block의 연습입니다. bbb의 값은 : " + bbb);
	}

	public static void main(String args[]) {
		System.out.println("main() 호출");
	}

}
```

## 10. 상속

객체지향의 특성을 가장 잘 나타낸다.

기존 클래스를 재활용 한다.

(항상 좋은 방법은 아니다.)

Java에서는 단일 상속만 지원한다.

→ `extends` keyword로 이어준다.

- 부모 클래스 (Parent class, Super class)
    
    = 상위 클래스 = Upper class
    
- 자식 클래스 (Child class, Sub class)
    
    = 하위 클래스 
    

→ class들은 결국 상속에 상속을 이어가면서 확장되어 만들고  사용된다.

→ Tree 구조로 만들어지게 된다.

Java의 모든 클래스는 상속 관계에 있다.

→ 코드에 대한 유지보수가 훨씬 좋아진다.

상속 다이어그램에서는 화살표를 상속 받은 class에서 상속을 준 class로 화살표를 이어준다.
