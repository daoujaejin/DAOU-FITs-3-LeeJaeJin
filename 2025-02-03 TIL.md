# 4조 SQL 발표 내용 정리

## 비즈니스 요구사항 정리

MTS DB 구현 → 영웅문 Small

(주식 거래 + 금융 상품 + 고객 관리) + 데이터 활용 종목 추천

## 테이블 설계 (변경점)

- 종목 테이블의 PK를 통합하여 2정규형 위반X
- 상품 테이블에서 먼저 인덱싱하여 종류별 검색 효율 증가
- 채권, 종목은 가격이 계속 달라짐 → 주문 테이블 연결
- 종목 - 회사 관계에 ZERO 불가능 (가격은 비상장 때문에 가능)
- 주문 테이블 미체결 수량 열 제거 → 제 3 정규화
- 불필요 PK 제거

## DB 스키마 (최종)

```sql
﻿CREATE TABLE "ACCOUNTS" (
	"ACCOUNT_ID"	NUMBER(20)		NOT NULL,
	"USER_ID"	VARCHAR(64)		NOT NULL,
	"STATUS"	VARCHAR(5)		NULL,
	"TYPE"	VARCHAR(5)		NULL,
	"PASSWORD"	VARCHAR(20)		NULL,
	"OPEN_DATE"	DATE		NULL,
	"CLOSE_DATE"	DATE		NULL,
	"WITHHOLDING"	NUMBER(20,2)		NULL,
	"DEPOSIT"	NUMBER(20,2)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "FUNDS" (
	"SEQUENCE"	NUMBER(2)		NOT NULL,
	"PRODUCT_ID"	NUMBER(10)		NOT NULL,
	"STOCK_TICKER"	VARCHAR(8)		NOT NULL,
	"PORTION"	NUMBER(4,2)		NULL,
	"PROFIT"	NUMBER(16,2)		NULL,
	"AMOUNT"	NUMBER(16,2)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "HOLDINGS" (
	"SEQUENCE"	NUMBER(4)		NOT NULL,
	"ACCOUNT_ID"	NUMBER(20)		NOT NULL,
	"STOCK_TICKER"	VARCHAR(8)		NOT NULL,
	"PRODUCT_ID"	NUMBER(10)		NOT NULL,
	"QUANTITY"	NUMBER(20, 6)		NULL,
	"CREAETE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "PRICES" (
	"BASE_DATE"	DATE		NOT NULL,
	"STOCK_TICKER"	VARCHAR(8)		NOT NULL,
	"OPEN"	NUMBER(10,2)		NULL,
	"HIGH"	NUMBER(10,2)		NULL,
	"LOW"	NUMBER(10,2)		NULL,
	"CLOSE"	NUMBER(10,2)		NULL,
	"VOLUME"	NUMBER(17)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "USERS" (
	"USER_ID"	VARCHAR(64)		NOT NULL,
	"PASSWORD"	VARCHAR(20)		NULL,
	"NAME"	VARCHAR(20)		NULL,
	"STATUS"	VARCHAR(4)		NULL,
	"TYPE"	VARCHAR(4)		NULL,
	"EMAIL"	VARCHAR(40)		NULL,
	"PHONE_NUMBER"	VARCHAR(20)		NULL,
	"AGE"	NUMBER(3)		NULL,
	"BIRTH_DATE"	DATE		NULL,
	"GENDER"	VARCHAR(4)		NULL,
	"INCOME"	NUMBER(20,2)		NULL,
	"TENDENCY_SELF"	NUMBER(1)		NULL,
	"TENDENCY_AI"	NUMBER(1)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "PRODUCTS" (
	"PRODUCT_ID"	NUMBER(10)		NOT NULL,
	"CLASS_CODE"	NUMBER(2)		NULL,
	"NAME"	VARCHAR(20)		NULL,
	"OPERATOR"	VARCHAR(10)		NULL,
	"CHARGE"	NUMBER(4,2)		NULL,
	"TENDENCY"	NUMBER(1)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "BONDS" (
	"PRODUCT_ID"	NUMBER(10)		NOT NULL,
	"OPTION_CLASS"	NUMBER(2)		NULL,
	"INTEREST_CLASS"	NUMBER(2)		NULL,
	"YIELD"	NUMBER(4,2)		NULL,
	"DURATION"	NUMBER(3)		NULL,
	"BOND_PRICE"	NUMBER(12,2)		NULL,
	"FACE_VALUE"	NUMBER(12,2)		NULL,
	"COMPANY"	VARCHAR(20)		NULL
);

CREATE TABLE "TRANSACTIONS" (
	"TRANSACTION_ID"	NUMBER(20)		NOT NULL,
	"ACCOUNT_ID"	NUMBER(20)		NOT NULL,
	"PRODUCT_ID"	NUMBER(10)		NOT NULL,
	"STOCK_TICKER"	VARCHAR(8)		NOT NULL,
	"STATUS"	VARCHAR(5)		NULL,
	"TYPE"	VARCHAR(5)		NULL,
	"QUANTITY"	NUMBER(20,6)		NULL,
	"PRICE"	NUMBER(20,2)		NULL,
	"TRADED"	NUMBER(20,6)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL,
	"CHARGE_RATE"	NUMBER(4,2)		NULL
);

CREATE TABLE "TRADES" (
	"TRADE_NUMBER"	NUMBER(20)		NOT NULL,
	"TRANSACTION_ID"	NUMBER(20)		NOT NULL,
	"BUYER_ACCOUNT_NUMBER"	NUMBER(20)		NULL,
	"SELLER_ACCOUNT_NUMBER"	NUMBER(20)		NULL,
	"QUANTITY"	NUMBER(20,6)		NULL,
	"PRICE"	NUMBER(20,2)		NULL,
	"CHARGE"	NUMBER(20,2)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "COMPANIES" (
	"BASE_DATE"	DATE		NOT NULL,
	"STOCK_TICKER"	VARCHAR(8)		NOT NULL,
	"QUARTER"	NUMBER(1)		NULL,
	"EARNINGS"	NUMBER(16,2)		NULL,
	"OPERATING_EXPENSE"	NUMBER(16,2)		NULL,
	"NET_PROFIT"	NUMBER(16,2)		NULL,
	"ASSET"	NUMBER(16,2)		NULL,
	"AMOUNT"	NUMBER(20)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

CREATE TABLE "TICKERS" (
	"STOCK_TICKER"	VARCHAR(8)		NOT NULL,
	"STATUS"	NUMBER(2)		NULL,
	"NAME"	VARCHAR(20)		NULL,
	"SECTOR"	NUMBER(3)		NULL,
	"LISTING_DATE"	DATE		NULL,
	"DELISTING_DATE"	DATE		NULL,
	"EXCHANGE_CODE"	VARCHAR(5)		NOT NULL,
	"TENDENCY"	NUMBER(1)		NULL,
	"CREATE_TIME"	DATE		NULL,
	"UPDATE_TIME"	DATE		NULL
);

ALTER TABLE "ACCOUNTS" ADD CONSTRAINT "PK_ACCOUNTS" PRIMARY KEY (
	"ACCOUNT_ID"
);

ALTER TABLE "FUNDS" ADD CONSTRAINT "PK_FUNDS" PRIMARY KEY (
	"SEQUENCE",
	"PRODUCT_ID"
);

ALTER TABLE "HOLDINGS" ADD CONSTRAINT "PK_HOLDINGS" PRIMARY KEY (
	"SEQUENCE",
	"ACCOUNT_ID"
);

ALTER TABLE "PRICES" ADD CONSTRAINT "PK_PRICES" PRIMARY KEY (
	"BASE_DATE",
	"STOCK_TICKER"
);

ALTER TABLE "USERS" ADD CONSTRAINT "PK_USERS" PRIMARY KEY (
	"USER_ID"
);

ALTER TABLE "PRODUCTS" ADD CONSTRAINT "PK_PRODUCTS" PRIMARY KEY (
	"PRODUCT_ID"
);

ALTER TABLE "BONDS" ADD CONSTRAINT "PK_BONDS" PRIMARY KEY (
	"PRODUCT_ID"
);

ALTER TABLE "TRANSACTIONS" ADD CONSTRAINT "PK_TRANSACTIONS" PRIMARY KEY (
	"TRANSACTION_ID"
);

ALTER TABLE "TRADES" ADD CONSTRAINT "PK_TRADES" PRIMARY KEY (
	"TRADE_NUMBER"
);

ALTER TABLE "COMPANIES" ADD CONSTRAINT "PK_COMPANIES" PRIMARY KEY (
	"BASE_DATE",
	"STOCK_TICKER"
);

ALTER TABLE "TICKERS" ADD CONSTRAINT "PK_TICKERS" PRIMARY KEY (
	"STOCK_TICKER"
);

ALTER TABLE "FUNDS" ADD CONSTRAINT "FK_PRODUCTS_TO_FUNDS_1" FOREIGN KEY (
	"PRODUCT_ID"
)
REFERENCES "PRODUCTS" (
	"PRODUCT_ID"
);

ALTER TABLE "HOLDINGS" ADD CONSTRAINT "FK_ACCOUNTS_TO_HOLDINGS_1" FOREIGN KEY (
	"ACCOUNT_ID"
)
REFERENCES "ACCOUNTS" (
	"ACCOUNT_ID"
);

ALTER TABLE "PRICES" ADD CONSTRAINT "FK_TICKERS_TO_PRICES_1" FOREIGN KEY (
	"STOCK_TICKER"
)
REFERENCES "TICKERS" (
	"STOCK_TICKER"
);

ALTER TABLE "BONDS" ADD CONSTRAINT "FK_PRODUCTS_TO_BONDS_1" FOREIGN KEY (
	"PRODUCT_ID"
)
REFERENCES "PRODUCTS" (
	"PRODUCT_ID"
);

ALTER TABLE "COMPANIES" ADD CONSTRAINT "FK_TICKERS_TO_COMPANIES_1" FOREIGN KEY (
	"STOCK_TICKER"
)
REFERENCES "TICKERS" (
	"STOCK_TICKER"
);

```

## 설계한 DB를 활용하는 쿼리문 작성

```sql
-- <1. 기본 정보 조회>
-- 고객 정보
SELECT NAME, EMAIL ID, INCOME FROM USERS
ORDER BY NAME;

-- 특정 주식 정보 (성향 추천 지표를 기반)
SELECT * FROM TICKERS
WHERE TENDENCY <= 3
ORDER BY NAME;

-- 금융상품 정보 (수수료 50달러 이상 내림차순 정렬)
SELECT * FROM PRODUCTS
WHERE CHARGE >= 50
ORDER BY CHARGE DESC;

-- <2. 거래 데이터 통계 분석>
-- 특정 기간 거래량
SELECT COUNT(*) AS "2010년~2019년 거래량" FROM TRADES
WHERE CREATE_TIME BETWEEN '100101' AND '191231';

-- 거래 총액
SELECT SUM(PRICE) "거래 총액" FROM TRADES;

-- 손익 분석
SELECT
    SUM(CASE WHEN TS.TYPE = 'SELL' THEN TD.PRICE ELSE 0 END) -
    SUM(CASE WHEN TS.TYPE = 'BUY' THEN TD.PRICE ELSE 0 END) AS PROFIT
FROM TRANSACTIONS TS
LEFT OUTER JOIN TRADES TD
    ON TS.TRANSACTION_ID = TD.TRANSACTION_ID;

-- <3. 주식 보유 현황 (각 고객이 보유한 주식 수량 및 보유 주식 별 평가액 총합)>
SELECT T.USER_ID 고객ID, COUNT(T.STOCK_TICKER) 보유주식수량, NVL(SUM(T.OPEN * T.QUANTITY),0) 평가액총합
FROM 
    (
    SELECT U.USER_ID USER_ID, H.STOCK_TICKER STOCK_TICKER, H.QUANTITY QUANTITY, P.OPEN OPEN
    FROM USERS U
    LEFT JOIN ACCOUNTS A
    ON U.USER_ID = A.USER_ID
    LEFT JOIN HOLDINGS H
    ON A.ACCOUNT_ID = H.ACCOUNT_ID 
    LEFT JOIN PRICES P
    ON H.STOCK_TICKER = P.STOCK_TICKER
    ) T 
WHERE T.USER_ID IS NOT NULL
GROUP BY GROUPING SETS(T.USER_ID)
ORDER BY 평가액총합 DESC;

-- <4. 주가 변동률 (시가 대비 종가)>
SELECT STOCK_TICKER 종목, BASE_DATE 거래일, OPEN 시가, CLOSE 종가, 
    ROUND((CLOSE - OPEN) / OPEN * 100) "일별 주가 변동률(%)"
FROM PRICES
ORDER BY 종목, 거래일;

-- <5. 각 계좌별 수익>
SELECT T.ACCOUNT_ID,
    SUM(CASE WHEN TYPE = 'SELL' THEN PRICE ELSE 0 END) -
    SUM(CASE WHEN TYPE = 'BUY' THEN PRICE ELSE 0 END) AS PROFIT
FROM
    (SELECT TS.ACCOUNT_ID, TS.TYPE, SUM(TD.PRICE) PRICE
    FROM TRANSACTIONS TS
    LEFT OUTER JOIN TRADES TD
        ON TS.TRANSACTION_ID = TD.TRANSACTION_ID
    GROUP BY TS.ACCOUNT_ID, TS.TYPE) T
GROUP BY ACCOUNT_ID;

-- <6. 거래량 순위 (~10위)>
SELECT * FROM (
    SELECT STOCK_TICKER 종목, SUM(D.QUANTITY) 거래량
    FROM TRADES D
    LEFT OUTER JOIN TRANSACTIONS J
        ON D.TRANSACTION_ID = J.TRANSACTION_ID
    WHERE STOCK_TICKER IS NOT NULL
    GROUP BY STOCK_TICKER
    ORDER BY COUNT(*)
)
WHERE ROWNUM <= 10;

-- <7. 고객의 성향에 맞는 종목 추천>
SELECT 고객명, T.NAME "추천 종목" FROM 
TICKERS T
JOIN (
    SELECT NAME 고객명, (TENDENCY_SELF + TENDENCY_AI) / 2 "지표"
    FROM USERS) C
    ON C.지표 - T.TENDENCY <= 1 AND C.지표 - T.TENDENCY >= -1;
    
-- <8. 고객의 성향에 맞는 상품 추천>
SELECT 고객명, P.NAME "추천 상품" FROM 
PRODUCTS P
JOIN (
    SELECT NAME 고객명, (TENDENCY_SELF + TENDENCY_AI) / 2 "지표"
    FROM USERS) C
    ON C.지표 - P.TENDENCY <= 1 AND C.지표 - P.TENDENCY >= -1;
```

## 인덱싱 활용

```sql
-- <인덱싱>
-- 섹터별 종목을 조회하는 일이 많을 수 있음. 연관 주식 추천 등에서 자주 쓰이기 때문에 섹터에 인덱싱
CREATE INDEX SECTOR_TICKERS ON TICKERS(SECTOR);

-- 개인화를 위한 성향추천지표에 인덱싱
-- 각 고객의 투자성향으로부터 추천이 시작되기 때문에 고객의 성향은 인덱싱하지 않는다.
CREATE INDEX TENDENCY_TICKERS ON TICKERS(TENDENCY);
CREATE INDEX TENDENCY_PRODUCTS ON PRODUCTS(TENDENCY);
```

## VIEW 활용

```sql
-- <지표 확인용 VIEW>
CREATE OR REPLACE VIEW INDICATORS_VIEW AS
    WITH RECENT_PRICES AS (
        SELECT STOCK_TICKER, OPEN
        FROM (
            SELECT STOCK_TICKER, BASE_DATE, OPEN,
                   ROW_NUMBER() OVER (PARTITION BY STOCK_TICKER ORDER BY BASE_DATE DESC) AS RN
            FROM PRICES
        )
        WHERE RN = 1
    )
    SELECT
        C.STOCK_TICKER,
        ROUND(C.EARNINGS /  C.ASSET * 100,2) AS ROE,
        ROUND(P.OPEN / C.ASSET * C.AMOUNT,2) AS PBR,
        ROUND(P.OPEN / C.NET_PROFIT * C.AMOUNT,2) AS PER,
        ROUND(P.OPEN / C.EARNINGS * C.AMOUNT,2) AS PSR
    FROM COMPANIES C
    JOIN RECENT_PRICES P ON C.STOCK_TICKER = P.STOCK_TICKER;
```

- RN: 순위번호
- ROE: 자기자본이익률
- PBR: 주가 순자산 비율
- PER: 주가 수익 비율
- PSR: 주가 매출 비율
