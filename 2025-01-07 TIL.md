## 1/7 단원 Test 복습

**디스크 공간 할당**은 입출력 시스템 관리에 해당되지 않는다.  
**DMA**: 직접적으로 입출력장치와 메모리를 연결

--- 
# 알고리즘

문제를 해결하기 위한 일련의 절차

## 시간복잡도

알고리즘이 얼마나 효율적으로 동작하는지 평가하는 척도

가장 큰 영향 = n의 단위

- 상수시간: O(1)
    
    입력에 관계없이 복잡도 동일
    
- 로그시간, 선형로그형: O(logn), O(nlogn)
    
    정렬 알고리즘에 많이 사용
    
- 직선형시간: O(n)
    
    입력이 증가하면 처리시간, 메모리 사용이 선형적으로 증가
    
- 2차시간: O($n^2$)
    
    반복문이 두 번 있는 경우
    
- 지수시간: O($c^n$)

## 점근적 표기법

시간 복잡도를 근사치로 표현한 것

- **오메가 표기법**: 최선의 경우
- **세타 표기법**: 평균적인 경우
- **빅오 표기법**: 최악의 경우

일반적으로 시간복잡도는 최악의 경우를 말한다.

# 자료구조

## 배열

같은 자료형의 데이터를 순서대로 나열한 구조

**인덱스**: 첫 번째로 부터 떨어진 상대적인 위치 → 데이터 삽입과 삭제에 사용

- 1차원 배열: 인덱스를 하나만 사용
- 2차원 배열: 두 개의 인덱스를 사용하는 배열

## 연결 리스트

각 데이터들을 포인터로 연결하여 관리

→ 데이터의 삽입과 삭제가 용이

- 단일 연결 리스트: 노드에 포인터 영역이 하나
- **이중 연결 리스트**: 다음 노드를 가리키는 포인터 + 이전 노드를 가리키는 포인터가 있는 연결 리스트

## 스택

데이터의 삽입과 삭제가 한쪽 방향에서만 일어나는 구조

**후입선출**: 가장 나중에 삽입된 데이터가 가장 먼저 삭제 (LIFO)

- **push**: 스택의 상단에 데이터를 삽입
- **pop**: 스택의 가장 상단의 데이터를 제거

## 큐

데이터가 한쪽 방향으로 삽입되고, 반대 방향으로 삭제되는 구조

**선입선출**: 가장 먼저 삽입된 데이터가 가장 먼저 삭제 (FIFO)

- **enqueue**: 큐의 뒤쪽에 새로운 데이터를 추가
- **dequeue**: 큐의 앞쪽에 있는 데이터를 제거

## 우선순위 큐

각 요소가 우선순위를 가지는 구조

우선순위가 높은 요소부터 꺼낸다.

## 그래프

**정점**과 **간선**으로 구성된 자료구조

<그래프 종류>

- **무방향 그래프**
- **방향 그래프**
- **완전 그래프**: 모든 정점 사이에 간선이 있는 그래프
- **가중 그래프**: 간선마다 가중치를 부여한 그래프
- **다중 그래프**: 다중간선이 있는 그래프
- **유사 그래프**: 다중 간선과 루프(자기를 연결한 정점)를 포함하는 그래프

<용어>

- **인접, 이웃**: 무방향 그래프에서 간선으로 연결된 두 정점
- **multiplicity**: 두 정점 사이의 정점의 개수
- **차수**: 정점에 접한 간선의 수
- **인접 리스트**: 정점별 인접한 정점의 리스트
- **인접 행렬**: 모든 정점의 연결유무를 연결된 수로 표현한 행렬
- **근접 행렬**: 정점과 간선의 관계를 나타내는 행렬
- **경로**: 간선을 연결하는 정점들을 나열한 것

## 깊이 우선 탐색 (DFS)

Depth-First Search

시작 정점에서 방문하지 않은 정점을 계속해서 방문한다.

진행할 수 없으면 아직 방문하지 않은 정점을 되돌아가며 방문한다.

## 너비 우선 탐색 (BFS)

Breadth-First Search

시작 정점을 먼저 방문하고, 시작 정점과 연결된 모든 정점을 방문한다.

그 다음 새롭게 방문한 정점들에 연결된 정점들에 방문한다.

## 트리

배열이나 연결리스트를 이용해서 구현

<용어>

- 서브 트리
- 부모 노드
- 자식 노드
- 형제 노드
- 레벨: 루트 노드에서 임의의 노드까지 방문한 노드의 수
- 깊이: 트리의 최대 레벨

### **이진 트리**

모든 노드들의 자식노드가 두 개 이하인 트리

- **완전 이진 트리**: 단말 노드를 제외한 모든 노드가 모두 두 개의 자식 노드를 가지고 있는 트리
- 포화 이진 트리: 완전 이진 트리 중 모든 노드가 채워진 이진 트리

<순회>

- **전위 순회**: 루트 → 왼쪽 → 오른쪽
- **중위 순회**: 왼쪽 → 루트 → 오른쪽
- **후위 순회**: 왼쪽 → 오른쪽 → 루트

### 이진 탐색 트리

같은 데이터를 갖는 노드가 없다.

왼쪽 서브 트리에 있는 모든 데이터 < 오른쪽 서브 트리에 있는 모든 데이터

균형 문제: 이진 탐색 트리가 균형을 이루지 않아 편향 상태가 될 수 있다.

연산이 비효율적이고, 검색 속도가 느려진다.

→ 균형 문제를 해결하기 위해 다양한 자기 균형 이진 탐색 트리(BST)을 사용한다.

ex) AVL 트리, 레드-블랙 트리

### 힙

완전 이진 트리에 기반하는 자료구조

우선순위 큐 구현에 주로 사용된다.

- **최소 힙**: 각 부모 노드 값이 자식 노드들의 값보다 작거나 같다.
- **최대 힙**: 각 부모 노드 값이 자식 노드들의 값보다 크거나 같다.

**힙 생성 알고리즘**: i 인덱스의 왼쪽 자식 노드 = 2*i + 1, 오른쪽 자식 노드 = 2*i + 2

<힙의 활용>

- 우선순위 큐
- 힙 정렬
- 최소 신장 트리
- **몬테카를로 트리 탐색**: 게임 인공지능 분야에서 활용되는 탐색 알고리즘
    
    반복적으로 트리를 확장하며 가능한 시나리오를 시뮬레이션하여 의사결정 한다.
    

## 탐색

- **선형 탐색**
    
    주어진 데이터 집합에서 원하는 데이터를 처음부터 순차적으로 비교하며 찾는 방법
    
- **이진 탐색**
    
    정렬된 데이터 집합을 반으로 쪼개 가면서 탐색하는 방법 (정렬된 배열)
    

## 정렬

- **선택 정렬**
    
    정렬되지 않은 데이터 중에 가장 작은 데이터를 가장 앞의 데이터와 교환 해나가는 정렬
    
- **삽입 정렬**
    
    아직 정렬되지 않은 임의의 데이터를 이미 정렬된 부분의 적절한 위치에 삽입해가며 정렬하는 방식
    
- **버블 정렬**
    
    서로 이웃한 데이터들을 비교해서 가장 큰 데이터를 맨 뒤로 보내며 정렬하는 방식
    
- **퀵 정렬**
    
    기준 피봇을 중심으로 작거나 같은 값은 앞으로, 큰 값은 뒤로 가도록 하고, 각 영역별 피봇을 다시 정하며 정렬하는 방식
    
- **병합 정렬**
    
    배열을 반으로 나누고, 배열을 재귀적으로 정렬하며 병합하며 정렬
    
- **힙 정렬**
    
    (최대힙이나 최소힙) 루트노드를 마지막 노드와 교환 후 힙크기를 줄이는 방식으로 정렬
    

## 추가적 내용들

- **해시 테이블**
    
    키를 이용해 데이터를 빠르게 검색할 수 있도록 설계된 자료구조
    
    충돌: 다른 키들이 동일 해시값을 반환하는 경우
    
    → 체이닝, 개방 주소법 등으로 해결
    
- **재귀 알고리즘**
    
    자기 자신을 호출하는 방식으로 문제를 해결
    
    → 피보나치에 사용
    
- **피보나치 수열**
    
    0, 1로 시작, 그 뒤는 f(n) = f(n - 1) + f(n - 2)
    
- **그리디 알고리즘**
    
    매 순간 최적의 선택을 하는 방법으로 문제를 해결하는 알고리즘
    
- **최소 신장 트리**
    
    그래프에서 모든 노드를 연결할 수 있는 트리 구조를 찾고, 트리 간선들의 가중치 합이 최소가 되도록 만드는 방법
    
- **다익스트라 알고리즘**
    
    단일 출발지 최단 경로 문제를 해결하는 알고리즘
    
- **동적 프로그래밍 (DP)**
    
    복잡한 문제를 작은 부분으로 나누어 해결하고, 그 결과를 저장하여 중복 계산을 방지하는 알고리즘 설계법
    
    ex) 배낭 문제, 피보나치 수열
