# JOIN

## 오라클 JOIN

```sql
SELECT E.EMPLOYEE_ID,
        E.NAME AS EMPLOYEE_NAME,
        D.DEPARTMENT_NAME,
        D.LOCATION
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID (+)
    AND D.LOCATION = 'New York';
```

# JOIN 실습

```sql
-- 1/16 팀 실습
-- (1)직원 이름과 소속 부서의 근무지를 조회
SELECT E.NAME "직원 이름", D.LOCATION 근무지
FROM EMPLOYEES E
JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- (2)직원 이름과 해당 직원의 매니저 이름을 조회 (매니저가 없는 직원도 출력)
SELECT E1.NAME "직원 이름", E2.NAME "매니저 이름"
FROM EMPLOYEES E1
LEFT OUTER JOIN EMPLOYEES E2
    ON E1.MANAGER_ID = E2.EMPLOYEE_ID;

-- (3)직원 이름과 급여를 조회 (급여가 NULL인 경우 N/A)
SELECT NAME "직원 이름", NVL(TO_CHAR(SALARY), 'N/A') 급여
FROM EMPLOYEES;

-- (4)근무지가 Chicago인 직원 이름과 급여를 조회
SELECT E.NAME "직원 이름", E.SALARY 급여
FROM EMPLOYEES E
JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE D.LOCATION = 'Chicago';

-- (5)급여가 5000이상 10000이하인 직원의 이름과 급여, 부서명 조회
SELECT E.NAME, E.SALARY, D.DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.SALARY BETWEEN 5000 AND 10000;

-- (6)최근 3개월 이내 입사한 직원 이름과 입사일 조회
SELECT NAME "직원 이름", HIRE_DATE 입사일
FROM EMPLOYEES
WHERE MONTHS_BETWEEN(SYSDATE, HIRE_DATE) <= 3;

-- (7)각 부서의 부서장 이름과 부서 이름을 조회
SELECT E.NAME "부서장 이름", D.DEPARTMENT_NAME "부서 이름"
FROM DEPARTMENTS D
LEFT OUTER JOIN EMPLOYEES E
    ON D.MANAGER_ID = E.EMPLOYEE_ID;

-- (8)직무별 직원수 조회
SELECT JOB_ID 직무, COUNT(*) 직원수
FROM EMPLOYEES
GROUP BY JOB_ID;

-- (9)부서명과 부서별 평균 급여
SELECT DEPARTMENT_NAME 부서명, CEIL(AVG(SALARY)) "평균 급여"
FROM EMPLOYEES E
JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;

-- (10)직원의 총 급여 합계 조회
SELECT SUM(SALARY) "총 급여 합계 조회"
FROM EMPLOYEES;

-- (11)대출 금액과 고객 이름을 대출 금액이 높은 사람부터 조회
SELECT L.AMOUNT "대출 금액", C.NAME "고객 이름"
FROM LOANS L
LEFT JOIN CUSTOMERS C
ON L.CUSTOMER_ID = C.CUSTOMER_ID
ORDER BY L.AMOUNT DESC;

-- (12)대출 상태별 고객 수 조회
SELECT STATUS "대출 상태", COUNT(DISTINCT(CUSTOMER_ID)) 고객수
FROM LOANS
GROUP BY STATUS;

-- (13)직원 수가 가장 적은 부서ID와 직원수를 조회
SELECT * FROM (
SELECT ROW_NUMBER() OVER(ORDER BY COUNT(*)) AS row_num, DEPARTMENT_ID 부서ID, COUNT(*) 직원수
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
) WHERE row_num = 1;

-- (14)월별 신규 고객 수를 최근 순으로 조회
SELECT SUBSTR(TRUNC(CREATED_AT, 'MM'),1,5) AS "생성 월", COUNT(*) 고객수
FROM CUSTOMERS
GROUP BY TRUNC(CREATED_AT, 'MM')
ORDER BY "생성 월" DESC;

-- (15)상품 카테고리와 상위 카테고리를 조회하세요 (단, 상위 카테고리가 없는 데이터도 출력)
SELECT
    S1.CATEGORY_NAME "상품 카테고리",
    S2.CATEGORY_NAME AS "상위 카테고리" 
FROM SHOPPING_CATEGORIES S1
LEFT OUTER JOIN SHOPPING_CATEGORIES S2
    ON S1.PARENT_CATEGORY_ID = S2.CATEGORY_ID;
    
-- (16)'Branch 8' 지점의 대출 총합을 조회 (소수점 아래는 버림)
SELECT B.NAME "지점 이름", FLOOR(COUNT(L.AMOUNT)) "대출 총합"
FROM BRANCHES B
JOIN LOANS L
    ON B.BRANCH_ID = L.BRANCH_ID
WHERE B.NAME = 'Branch 8'
GROUP BY B.NAME;

-- (17)직무별 직원의 평균 급여를 계한하여 등급에 따라 출력
SELECT JOB_ID 직무, AVG(SALARY) 평균급여,
CASE 
    WHEN AVG(SALARY)>= 8000 THEN 'HIGH'
    WHEN AVG(SALARY)>= 6000 THEN 'MEDIUM'
    WHEN AVG(SALARY)>=5000 THEN 'LOW'
END 수준
FROM EMPLOYEES GROUP BY JOB_ID
ORDER BY 평균급여 DESC;

-- (18)고객별 이름과 거래 내역(금액)을 조회, 고객 이름으로 오름차순
SELECT NAME "고객 이름", SUM(T.AMOUNT) "거래 내역(금액)" 
FROM CUSTOMERS C
JOIN ACCOUNTS A
    ON C.CUSTOMER_ID = A.CUSTOMER_ID
JOIN TRANSACTIONS T
    ON A.ACCOUNT_ID = T.ACCOUNT_ID
GROUP BY C.NAME
ORDER BY TO_NUMBER(SUBSTR(C.NAME, 10, 12));

-- (19)부서별 평균 근속일, 부서 이름으로 오름차순 정렬 (평균 근속일은 반올림하여 정수로)
SELECT DEPARTMENT_NAME "부서 이름", ROUND(AVG(J.END_DATE - J.START_DATE))
FROM DEPARTMENTS D
JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN JOB_HISTORY J
    ON E.EMPLOYEE_ID = J.EMPLOYEE_ID
GROUP BY D.DEPARTMENT_NAME
ORDER BY D.DEPARTMENT_NAME;

-- (20)대출 금액이 가장 높은 상위 5명의 고객의 이름과 대출 금액을 조회 (대출금액이 동일한 경우 이름으로)
SELECT C.NAME, T.TOTAL_LOAN
FROM (
    SELECT C.CUSTOMER_ID, SUM(L.AMOUNT) AS TOTAL_LOAN
    FROM CUSTOMERS C
    LEFT JOIN LOANS L
        ON C.CUSTOMER_ID = L.CUSTOMER_ID
    GROUP BY C.CUSTOMER_ID
    ORDER BY SUM(L.AMOUNT) DESC NULLS LAST) T
JOIN CUSTOMERS C
    ON C.CUSTOMER_ID = T.CUSTOMER_ID
WHERE ROWNUM <=5;
```

# 복습

## LIKE

- %, _를 통해 문자열 패턴을 검색할 수 있다.
- ESCAPE: %나 _를 문자로 사용하고 싶을 때

## IN

- 지정된 값중 하나와 일치하는 데이터를 찾음

## BETWEEN

- 지정된 범위 내에 있는 값을 찾음
- 시작, 끝 값 포함

## IS NULL

- IS NULL
- IS NOT NULL

## ORDER BY

- ASC: 오름차순
- DESC: 내림차순
- 여러개 조건이면 순서에 따라 정렬한다.
- NULL FIRST, NULL LAST

## 페이징 쿼리

- row_num을 통해 밖에서 조건을 준다.

## DISTINCT

- SQL에서 중복된 데이터를 제거하여 고유한 값만 반환
- 데이터 요약/집계에 유용

## GROUP BY

- 데이터베이스에서 데이터를 특정 기준으로 묶는 작업
- 집계 함수와 함께 사용

## WHERE, HAVING

- WHERE절은 GROUP BY 전에 조건을 필터링
- HAVING절은 집계 데이터에 대한 조건을 필터링
- WHERE절에서 가능한 조건은 모두 처리한 후 HAVING절로 넘어가기

## 올림, 반올림 함수

- CEIL
- FLOOR
- ROUND
- 음수 반올림: 부호 떼고 반올림 후 부호 다시 붙이기

## CASE WHEN

- 특정 조건에 따라 다른 값을 반환
