# 2/7 recap

- 4/5
- 1번, 3번
    
    instance의 메소드를 호출할 때는 동적바인딩이 되어서 실제 객체 타입에 맞는 오버라이딩 된 메소드를 호출하게 된다.
    
    - field → type을 따라간다.
    - method → type에 상관 없이 최후에 overriding된 메서드를 호출한다. (동적바인딩)
---
## 2. String class

문자열은 자료형이 아니라 String class로 제공된다.

- 객체가 생성되는 heap 영역에 **String Pool** 이라는 영역이 있다.
    - 대부분의 class → instance를 만들 때 new 키워드를 이용하고, 생성자가 호출된다.
    - String 객체는 `""` 을 이용하여 생성한 **리터럴 값**을 대입하여 생성
        
        ```java
        String name = "홍길동"; // 객체
        ```
        
- String은 **immutable(불변성)** 특징이 있다.
- 같은 내용의 String 객체가 또 생기면 새로운 데이터 영역을 할당하지 않고 기존의 공간을 가리키게 된다.
    
    ```java
    String test = "홍길동";
    System.out.println(name == test); // true
    
    String obj = new String("홍길동");
    System.out.println(name == obj); // false
    
    // equals() 오버라이딩
    System.out.println(name.equals(obj)); // true
    ```
    
    → String을 비교 할 때는 **equals()**를 사용한다!
    

## 3. Array

배열

- 같은 type의 데이터 여러 개를 저장할 수 있는 자료구조
- 배열은 객체이다.
- new 키워드를 사용하여 생성
- []를 type 뒤에 붙이는 것이 java 스타일이다.

## 4. ArrayList

계열

- List 계열
    
    ArrayList class
    
- Map 계열
    
    HashMap class
    
- Set 계열
    
    HashSet class
    

**ArrayList**

- 배열과 유사하다.
- 크기가 유동적이다.
- 다른 데이터 타입을 저장할 수 있다.
    
    대부분은 같은 데이터타입으로만 사용한다. (generic 사용)
    
    ```java
    ArrayList<String> list = new ArrayList<String>();
    	list.add("홍길동");
    	list.add("안녕안녕!");
    ```
    
- instance만 저장할 수 있다.
- primitive type은 Java에서 제공하는 **wrapper class**를 사용한다.
    
    **auto boxing**으로 값만 넣으면 객체를 생성해서 들어간다.
    

- 객체이기 때문에 당연히 method를 통해서 객체를 제어
- 각 개체에 대한 반복 동작을 할 때는 확장for문을 활용한다.
    
    ```java
    for(Object o : list) {
    	System.out.println(o);
    }
    ```
    
- 일반적인 표현
    
    상위 type으로 작성 → 유연해짐
    
    ```java
    List<String> list = new ArrayList<String>();
    ```
    

## 5. HashMap class

map: (key, value) 쌍으로 데이터를 저장하는 자료구조

- 집합형 자료구조
- key - value 쌍으로 저장
- key, value 둘 다 객체만 사용 가능
- 일반적으로는 순서 개념을 사용하지 않는다.
    
    (효율을 위해 몇몇 맵에는 있다.)
    
- `put()` `get()` 메서드로 데이터를 다룬다.

```java
public class HashMapTest {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<Integer, String>();

        map.put(1, "홍길동");
        map.put(2, "홍길동");

        // 데이터를 가져올때는 get() method 이용
        System.out.println(map.get(2));
    }
}
```

## 6. HashSet

set: 중복이 없는 데이터들의 자료구조

- 순서 개념이 없다.
- 데이터들이 바구니 안에 모여있는 형태
- 중복된 데이터 존재 불가능
- index가 없기 때문에 **iterator**을 사용해서 반복작업을 처리한다.

```java
public class HashSetTest {
    public static void main(String[] args) {
        Set<String> set = new HashSet<String>();

        set.add("홍길동");
        set.add("신사임당");
        set.add("강감찬");
        set.add("홍길동"); // 추가되지 않는다.

        Iterator<String> iter = set.iterator();
        while(iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}
```

## 7. Exception

예외를 다루는 class

- 특정 상황이 발생하면 이 class의 instance가 JVM에 의해서 생성된다.
- exception handling: 예외가 발생해도 상황을 잘 처리하여 프로그램을 유지시킬 수 있는 역할
    
    → 프로그램이 비정상 종료가 되는 것을 방지하는 기능
    
- `try {}` `catch {}` 구문을 이용
- `finally()` 구문은 무조건 실행된다.

```java
public class ExceptionTest {
    public static void main(String[] args) {
        System.out.println("Exception이 발생해요!");

        Object obj = null;
        try {
            // int res = 10 / 0; // ArithmaticException
            System.out.println(obj.toString()); // NullPointerExeption
        } catch (NullPointerException e) {
            // 예외상황을 처리할 수 있는 처리 코드가 나와야해요!
            // 강제종료되지 않는다.
            System.out.println("예외상황처리를 해야해요!");
        } catch (ArithmeticException e1) {
            // 예외상황을 처리할 수 있는 처리 코드가 나와야해요!
            // 강제종료되지 않는다.
            System.out.println("수학연산처리 오류처리를 해야해요!");
        } catch (Exception e) {
            // 예외상황을 처리할 수 있는 처리 코드가 나와야해요!
            // 강제종료되지 않는다.
            System.out.println("예외상황처리를 해야해요!");
        } finally {
            System.out.println("이 코드는 무조건 실행되요!");
        }
        // 이 코드에서 Exception이 발생
        // 이 상황에 맞는 Exception class를 이용해 JVM이 객체를 생성
        // 이 생성된 객체를 우리가 처리하지 않으면 프로그램이 비정상 종료됨

        System.out.println("프로그램이 종료되요!");
    }
}
```

- catch문에 Exception 매개변수를 넣으려면 가장 마지막에 넣어야 한다.
