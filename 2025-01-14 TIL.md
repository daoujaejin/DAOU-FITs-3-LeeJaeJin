# 정규화

- 데이터베이스의 설계 단계에서 데이터 **중복을 제거**하고, 데이터 **무결성**을 유지하기 위한 과정
- 데이터 저장소의 효율성 향상

## 제1정규형 (1NF)

모든 속성은 하나의 값만 가져야 한다.

여러 값을 가진 속성을 각각 속성으로 정규화 시킨다.

유사한 속성이 반복되는 경우도 1차 정규화의 대상이다.

**제1정규형에 위배가 되는 대상들은 제1정규화의 대상이다.**

ex) 여러 SNS를 연동해서 사이트에 로그인을 할 때 1명의 회원에 대해 여러 SNS를 제1정규화 해놓는다.

## 제2정규형 (2NF)

(제1정규형은 만족 상태)

엔터티의 모든 일반속성은 반드시 **모든 주식별자에 종속**되어야 한다.

ex) 주식별자: 주문번호, 음료코드

일반속성: 음료명 → 음료코드에 종속

삭제이상, 삽입이상, 갱신이상이 생길 수 있다.

→ 음료 관련 테이블을 생성하여 관리한다.

## 제3정규형 (3NF)

(제2정규형까지 만족 상태)

주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다.

→ 일반속성 사이의 종속은 테이블을 생성하여 제3정규화 한다.

# 반정규화

정규형을 다시 정규화 전으로 돌리는 것

- 다시 결합 & 중복 데이터 허용하는 과정
- 성능 최적화와 효율적인 데이터 엑세스를 위한 과정

→ 설계가 거의 끝났을 때 많이 한다.

## 반정규화의 필요성

- 정규화의 한계
    - 다수의 테이블이 조인이 필요한 쿼리에서는 성능 저하가 발생한다.
    - 읽기 속도가 중요한 상황에서는 정규화된 모델이 비효율적이다.
- 성능
    
    쿼리 성능을 개선하기 위해 데이터를 중복 저장하거나 데이블을 합치는 방식으로 **읽기 속도를 높인다**.
    
    → 주로 OLAP시스템에서 활용
    

## 반정규화 적용 방법

- **속성 추가**
    
    ex) ORDERS 테이블에 CUSTOMER_NAME 속성을 추가, 직접 조회
    
- **테이블 병합**
    
    PRODUCTS, PRODUCT_DETAILS 두 테이블을 하나의 테이블로 병합
    
- **중복 데이터 저장**
    
    요약 데이터를 미리 계산하고 테이블에 저장
    
- **이력 데이터 관리**
    
    트랜잭션 데이터 외에도 과거 데이터를 효율적으로 조회하기 위해 반정규화 적용
    

## 반정규화의 장점

- **성능 개선**
    
    읽기 속도 증가
    
    조인 연산 감소
    
    → 대규모 데이터 분석, 보고서 생성 시 유리
    
- **간단한 쿼리**
    
    사용자가 테이블 구조를 쉽게 이해할 수 있음
    
- **특정 요구사항 대응**
    
    특정 데이터 집합을 자주 조회해야 하는 경우 적합
    

## 반정규화의 단점

(= 정규화의 장점)

- **데이터 중복**
- **데이터 무결성 문제**
    
    업데이트나 삭제 시 데이터 불일치 가능성 높아짐
    
- **유연성 감소**

# OLTP vs OLAP

데이터 레이크: OLTP성 데이터를 모두 한 곳으로 모은다.

ware house: 큰 규모의 OLAP 시스템

## OLTP (Online Transaction Processing)

- 실시간으로 다수의 트랜잭션을 처리하는 시스템
- 주요 목적: 데이터 입력, 저장, 수정, 빠른 조회
    
    ex) 은행 시스템, 전자상거래, 예약 시스템
    
- 특징
    - **실시간 처리**: 다수의 사용자 요청을 신속하게 처리
    - **정규화된 데이터 구조**: 데이터 중복 최소화 & 데이터 무결성 유지
    - **트랜잭션 관리**: ACID 속성 (Atomicity, Consistency, Isolation, Durability)
- 구성 요소
    - **데이터베이스**: 관계형 데이터베이스
    - **애플리케이션**: 웹, 모바일 기반 트랜잭션 처리 애플리케이션
    - **사용자**: 실시간으로 데이터를 입력, 조회하는 최종 사용자

## OLAP (Online Analytical Processing)

예전에는 OLTP로 모두 운영했지만, 요즘에는 OLAP를 대부분 사용한다. 

- 대규모 데이터를 분석, 요약 정보와 통찰력을 제공하는 시스템
- 주요 목적: 데이터 분석, 보고서 생성, 비즈니스 인사이트 제공
    
    ex) 데이터 마트, 비즈니스 인텔리전스, 대시보드 시스템
    
- 특징
    - **복잡한 분석**: 집계, 요약, 패턴 분석 쿼리를 통해 비즈니스 인사이트 제공
    - **대규모 데이터 처리**: 데이터 웨어하우스, 데이터 마트를 활용하여 분석
    - **다차원 데이터 분석**: 시간, 지역, 제품 등 여러 차원을 기준으로 데이터 요약
- 구성 요소
    - **데이터 웨어하우스**: 정형, 비정형 데이터를 통합하고 분석 중심으로 저장
    - **OLAP 서버**: 분석 쿼리를 실행하며, 다차원 데이터 모델 제공
    - **사용자 인터페이스**: 분석 결과를 시각적으로 제공하는 대시보드, 리포트

## OLTP와 OLAP 상호작용

- OLTP 시스템은 데이터 생성, OLAP 시스템은 데이터 활용
- OLTP에서 생성된 데이터를 OLAP로 추출하여 분석
- **ETL 프로세스**: 데이터 웨어하우스로 데이터를 전송하기 위해 사용
    
    = Extract, Transform, Load
    
- **OLTP → ETL → OLAP** 흐름

## 논리 모델

- 데이터베이스 설계의 한 단계로, 데이터 구조와 관계를 기술하는 모델
- 특정 DBMS에 종속되지 않는다.
- 엔터티(Entity)와 속성(Attribute)을 정의한다.
- 관계(Relationship), 제약 조건 표현
- 데이터 중복 제거를 위한 정규화 적용

## 물리 모델

- 데이터베이스 설계의 최종 단계로, DBMS에 종속적인 데이터구조
- 데이터의 저장소, 성능, 보안을 고려하여 구현
- 데이터 타입과 제약조건 지정
- 인덱스, 파티션, 저장소 구조 설계
- DBMS의 기술적 제약 및 성능 최적화 반영

## 논리 모델 → 물리 모델

- 논리 모델에서 정의된 엔터티와 관계를 기반으로 물리적 테이블 생성
- 속성을 데이터 타입과 제약 조건으로 매핑
- 데이터베이스 성능을 고려하여 인덱스와 파티션 추가
- 변환 시 고려사항
    - 데이터베이스의 크기와 예상 트래픽
    - 읽기 및 쓰기 작업의 비율
    - DBMS의 기능 및 제약

# SQL 개념

## SQL이란

= Structured Query Language (데이터베이스를 관리, 조작하기 위한 언어)

- 관계형 데이터베이스에서 데이터를 CRUD하는 데 사용
- 데이터 정의, 조작, 제어를 위한 명령어 집합 제공

## SQL 분류

- **DDL**: 데이터베이스 구조 정의
- **DML**: 데이터를 조작 (삽입, 수정, 삭제)
- **DCL**: 데이터 접근 권한 제어
- **TCL**: 트랜잭션 관리 (Commit, Rollback)

## DDL

데이터베이스 객체를 정의하거나 변경하는 데 사용

- CREATE: 테이블, 뷰, 인덱스 생성
- ALTER: 기존 객체 수정
- DROP: 객체 삭제
- TRUNCATE: 테이블 데이터 초기화
    
    DB에서 모든 행동은 기록되지만, TRUNCATE는 남지 않는다. (롤백 불가능)
    
    → 빠르지만 위험하다.
    

### DDL - CREATE

```sql
CREATE TABLE CUSTOMERS (
	CUSTOMER_ID NUMBER PRIMARY KEY,
	NAME VARCHAR2(50) NOT NULL, 
	EMAIL VARCHAR2(100) UNIQUE,
	CREATED_AT DATE DEFAULT SYSDATE
);
```

### DDL - ALTER

- 칼럼 추가

```sql
ALTER TABLE CUSTOMERS ADD ADDRESS VARCHAR2(200);
```

- 칼럼 사이즈 OR 데이터 타입 변경

```sql
ALTER TABLE CLIENTS MODIFY CONTACT_EMAIL VARCHAR2(200);
```

- 컬럼 삭제

```sql
ALTER TABLE CLIENTS DROP COLUMN PHONE;
```

- 컬럼명 변경

```sql
ALTER TABLE CLIENTS RENAME NAME TO FULL_NAME;
```

- 테이블명 변경

```sql
ALTER TABLE CUSTOMERS RENAME TO CLIENTS;
```

### DDL - DROP, TRUNCATE

- 테이블 삭제

```sql
DROP TABLE CUSTOMERS;
```

- 테이블 데이터 초기화

```sql
TRUNCATE TABLE CUSTOMERS;
```

## DML

데이터베이스의 데이터를 조작하는 데 사용

- **SELECT**: 데이터 검색
- **INSERT**: 데이터 삽입
- **UPDATE**: 데이터 수정
- **DELETE**: 데이터 삭제

→ 고객들이 컨트롤하는 영역

### DML - INSERT, SELECT

- 데이터 삽입

```sql
INSERT INTO CUSTOMERS (CUSTOMER_ID, NAME, EMAIL, PHONE)
VALUES (1, 'JAEJILEE', 'JAEJILEE@NAVER.COM', '111-222');
```

- 데이터 조회

```sql
SELECT NAME, EMAIL
FROM CUSTOMERS
WHERE PHONE = '111-222';
```

### DML - UPDATE, DELETE

- 데이터 변경

```sql
UPDATE CUSTOMERS
SET EMAIL = 'JAEJILEE@NAVER.COM'
WHERE CUSTOMER_ID = 1;
```

- 데이터 삭제

```sql
DELETE FROM CUSTOMERS
WHERE CUSTOMER_ID = 1;
```

## DCL

데이터베이스 접근 권한을 관리

- GRANT: 권한 부여

```sql
GRANT SELECT ON CUSTOMERS TO USER1;
```

- REVOKE: 권한 회수

```sql
REVOKE SELECT ON CUSTOMERS FROM USER1;
```

## TCL

트랜잭션 관리를 위한 명령어 제공

- COMMIT: 트랜잭션 확정

```sql
INSERT INTO CUSTOMERS (CUSTOMER_ID, NAME)
VALUES (2, 'JAEJILEE')
COMMIT;
```

- ROLLBACK: 트랜잭션 취소

```sql
DELETE FROM CUSTOMERS
WHERE CUSTOMER_ID = 2;
ROLLBACK;
```

- SAVEPOINT: 특정 지점 저장

# SELECT 기초

## SELECT

- SQL에서 데이터를 검색하는 명령어
- 테이블에서 원하는 데이터를 추출
- 조건, 정렬, 그룹핑
- 업무에서 가장 많이 사용하게 될 구문
- 기본 문법: SELECT 컬럼명 FROM 테이블명;
    
    ex) SELECT NAME,SALARY FROM EMPLOYEES;
    
    *, COLUMN의 개수와 성능은 상관 없다. (DBMS는 블록 단위로 데이터를 저장하기 때문에)
    

## ALIAS

SQL 쿼리에서 컬럼이나 테이블에 부여하는 임시 이름

→ 결과 집합의 가독성을 높이고 복잡한 쿼리를 간결하게 작성할 수 있다.

- 테이블이나 컬럼 이름 대신 사용할 수 있다.
- DB 구조에 영향을 주지 않는 임시 이름
- 컬럼 ALIAS는 AS키워드를 사용하지만, 생략 가능
- 특수문자, 한글 등은 쌍따옴표로 감싸서 사용

### 컬럼 ALIAS

사용 이유: 연산 결과에 의미 부여, 가독성 높임

문법:

```sql
SELECT 컬럼명 (AS) 별칭

FROM 테이블명;
```

### 테이블 ALIAS

사용 이유: 테이블 이름이 길거나 복잡할 때 갖결하게 대체

→ JOIN 쿼리에서 테이블 이름을 축약하여 사용

문법:

```sql
SELECT 컬럼명 FROM 테이블명 별칭;
```

# NULL

- DB에서 NULL은 “값이 없음”을 의미
- 0, “” 과는 다름
- 정의되지 않은 상태

## NULL 연산

- NULL 값은 다른 값과 비교할 수 없음
- 비교 연산 (=, <>, <, >, ≤, ≥)을 수행하면 항상 FALSE 반환
- 세로 열 연산에서 중간에 NULL이 있으면 그 행은 제외하고 연산한다.
- 분자, 분모 계산에서도 NULL이 있는 데이터는 제외한다.

# WHERE

- WHERE 절로 조건을 지정하여 데이터를 필터링
- SELECT, UPDATE, DELETE와 함께 사용

## WHERE 절 연산자

- 다양한 연산자를 활용하여 복잡한 조건 설정 가능
- 비교 연산자
    - =: 같은지
    - <>: 다른지
    - <, >, ≤, ≥: 비교
- 논리 연산자: AND, OR, NOT
- 특수 연산자
    - **LIKE**
        
        특정 패턴을 가진 데이터를 검색
        
        - %: 0개 이상의 문자를 대체
        - _: 1개의 문자를 대체
        - ‘%’, ‘_’를 문자로 사용하려면 ESCAPE 문자로 구분한다.
    - **IN**
        
        지정된 값 중 하나와 일치하는 데이터를 찾음
        
        OR 조건으로 대체 가능
        
    - **BETWEEN**
        
        지정된 범위 내에 있는 값을 찾음
        
        범위는 시작 값과 끝 값을 포함
        
    - **IS NULL**
        
        NULL 값을 가진 데이터를 찾음
        
        IS NOT NULL → NULL이 아닌 데이터를 찾음
        

## 연산자의 우선순위

1. 괄호()
2. 비교 연산자
3. 논리 연산자 `NOT`
4. 논리 연산자 `AND`
5. 논리 연산자 `OR`

# 트랜잭션

데이터베이스에서 하나의 논리적 작업 단위를 의미

→ 데이터의 무결성과 일관성을 유지하기 위한 기본 단위

## 트랜잭션 특징 (ACID)

- **Atomicity (원자성)**
    - 트랜잭션은 모두 실행되거나, 실행되지 않아야 함
    - 실패 시 모든 변경 사항을 ROLLBACK하여 원상태로 복구
    
    ex) 계좌 이체 서비스에서 한 작업이라도 실패하면 전체 트랜잭션이 취소
    
- **Consistency (일관성)**
    - 트랜잭션이 성공적으로 완료된 후 데이터베이스는 항상 일관된 상태를 유지해야 한다.
    - 데이터 무결성을 보장한다.
    
    ex) 데이터베이스의 모든 외래 키 관계가 트랜잭션 후에도 유지
    
- **Isolation (고립성)**
    - 여러 트랜잭션이 동시에 실행될 때 서로 간섭하지 않도록 독립적으로 처리
    - 트랜잭션 격리 수준으로 구현
    
    ex) 한 트랜잭션이 수정 중인 데이터를 다른 트랜잭션이 볼 수 없다.
    
- **Durability (지속성)**
    - 트랜잭션이 성공적으로 완료되면 변경된 데이터는 영구적으로 저장
    - 시스템 장애 후에도 데이터는 유지
    
    ex) 트랜잭션이 COMMIT된 후 디스크에 기록된 데이터는 손실되지 않는다.
    

## 트랜잭션 설계 시 유의 사항

- 작업 단위를 명확히 정의
- 최소한의 데이터 변셩
- 장기 트랜잭션 방지
- 적절한 격리 수준 설정
