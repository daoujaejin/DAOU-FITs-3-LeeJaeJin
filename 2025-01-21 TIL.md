# 윈도우 함수

## 순위 함수

- **RANK**
    
    1,2,2,4,5,5,7,…
    
- **DENSE_RANK**
    
    1,2,2,3,4,5,5,6,…
    
- **ROW_NUMBER**
    
    1,2,3,4,5,6,…
    
    동일한 데이터도 다른 순위로 매겨짐 (랜덤)
    

## 집계 함수

- SUM
- AVG
- MAX
- COUNT
- PARTITION BY: 데이터를 특정 그룹으로 나눔
- ORDER BY: 데이터를 정렬 (누적 계산에 사용)

## 윈도우 함수 옵션

- **ROWS**
    
    행을 기준으로 범위 지정
    
    ```sql
    -- ROWS
    SELECT EMPLOYEE_ID, SALARY,
        SUM(SALARY) OVER (ORDER BY SALARY
        ROWS 2 PRECEDING) AS SALARY_SUM
    FROM EMPLOYEES;
    ```
    
- **RANGE**
    
    Value를 기준으로 범위 지정
    
    ```sql
    -- RANGE
    SELECT EMPLOYEE_ID, SALARY,
        SUM(SALARY) OVER (ORDER BY SALARY
        RANGE UNBOUNDED PRECEDING) AS SALARY_SUM
    FROM EMPLOYEES;
    ```
    
- **UNBOUNDED PRECEDING**
    
    처음 행
    
- **CURRENT ROW**
    
    현재 행
    
    ```sql
    -- CURRENT ROW
    SELECT EMPLOYEE_ID, SALARY,
        SUM(SALARY) OVER (ORDER BY SALARY
        ROWS BETWEEN CURRENT ROW
        AND UNBOUNDED FOLLOWING) AS
    FUTURE_SUM
    FROM EMPLOYEES;
    ```
    
- **FOLLOWING**
    
    뒤의 행
    
    ```sql
    -- FOLLOWING
    SELECT EMPLOYEE_ID, SALARY,
        SUM(SALARY) OVER (ORDER BY SALARY
        ROWS BETWEEN CURRENT ROW
        AND 2 FOLLOWING) AS SUM_NEXT_2
    FROM EMPLOYEES;
    ```
    
- 복합
    
    ```sql
    -- 복합 옵션 예제
    SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID
        ORDER BY SALARY ROWS UNBOUNDED PRECEDING)
        AS CUM_SALARY
    FROM EMPLOYEES;
    ```
    

## 종합 예제

```sql
-- 1. 직무별 상위 3명의 직원
-- 각 직무별로 급여가 가장 높은 3명의 직원 정보를 조회하세요. 
-- 출력 컬럼은 직무, 사번, 이름, 급여, 순위이고 직무, 순위로 정렬합니다.
SELECT * FROM (
    SELECT JOB_ID 직무, EMPLOYEE_ID 사번, NAME 이름, SALARY 급여,
        ROW_NUMBER() OVER (PARTITION BY JOB_ID ORDER BY SALARY) 순위
    FROM EMPLOYEES)
WHERE 순위 <= 3;
-- ORDER BY 직무, 순위;

-- 2. 직원 입사 연도별 총 급여 및 누적 급여
-- 직원들의 입사 연도별 총 급여와 해당 연도의 누적 급여를 계산하세요.
SELECT "입사 연도", "연도별 총 급여", 
    SUM("연도별 총 급여") OVER (ORDER BY "입사 연도") "누적 급여"
FROM (
    SELECT "입사 연도", SUM(SALARY) "연도별 총 급여" FROM (
        SELECT TO_CHAR(HIRE_DATE, 'YYYY') "입사 연도", SALARY
        FROM EMPLOYEES)
    GROUP BY "입사 연도");

-- 3. 직원별 급여 순위와 부서 평균 급여 비교
-- 모든 직원에 대해 급여 순위를 계산하고, 각 직원의 급여가 부서 평균 급여보다 높은지 확인하세요. 
-- 부서 평균 급여보다 높은 경우 ‘높다’라고 출력하고 낮은 경우 ‘낮다’라고 출력합니다. 
-- (출력 컬럼은 사번, 이름, 급여, 급여 순위, 부서 평균 급여, 높은지 낮은지 여부)
SELECT EMPLOYEE_ID 사번, NAME 이름, SALARY 급여,
    RANK() OVER (ORDER BY SALARY DESC NULLS LAST) "급여 순위",
    AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID) "부서 평균 급여",
    CASE
        WHEN SALARY > AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID) THEN '높다'
        ELSE '낮다'
    END "부서 내 급여"
FROM EMPLOYEES;

-- 4번 최근 1년간 대출을 받은 고객 중 총 대출 금액 상위 5명
-- 최근 1년 동안 대출을 받은 고객의 총 대출 금액을 계산하고, 
-- 이 금액이 상위 5명인 고객의 이름과 대출 금액을 출력하세요.
SELECT (SELECT NAME FROM CUSTOMERS WHERE L.CUSTOMER_ID = CUSTOMER_ID) "고객 이름", "대출 금액" FROM (
    SELECT CUSTOMER_ID, SUM(AMOUNT) "대출 금액" FROM (
        SELECT CUSTOMER_ID, AMOUNT
        FROM LOANS
        WHERE MONTHS_BETWEEN(SYSDATE, LOAN_DATE) <= 12 
            AND STATUS = 'APPROVED')
    GROUP BY CUSTOMER_ID
    ORDER BY "대출 금액" DESC) L
WHERE ROWNUM <= 5;

-- 5. 이동 평균 (Moving Average)
-- 직원 테이블에서 직원의 급여(SALARY)를 기준으로 직원 ID 순서대로 3명의 이동 평균을 계산하세요. 
-- 여기서 이동 평균은 현재 직원의 급여와 바로 이전 직원 2명의 급여를 포함합니다. 
-- 직원 ID, 이름, 급여, 그리고 이동 평균을 출력하세요. 
-- 이동 평균값은 반올림하여 소수점 아래 둘째 자리까지 표현합니다.
SELECT * FROM (
SELECT EMPLOYEE_ID ID, NAME 이름, SALARY 급여,
    ROUND(AVG(SALARY) OVER (ORDER BY EMPLOYEE_ID
    ROWS 2 PRECEDING), 2) "이동 평균"
FROM EMPLOYEES)
WHERE ROWNUM <= 3;

-- 6. 계좌 잔액이 평균 잔액 이상인 고객과 대출 금액이 평균 대출 금액 이상인 고객의 병합
-- 계좌 잔액이 전 계좌의 평균 잔액 이상인 고객과 
-- 대출 금액이 전체 평균 대출 금액 이상인 고객을 병합하여 고객 이름과 금액을 조회하세요. 
-- 출력 데이터에 출처가 “계좌” 인지 “대출”인지도 하나의 컬럼으로 나타내 주세요.
SELECT
    (SELECT NAME FROM CUSTOMERS C WHERE C.CUSTOMER_ID=L.CUSTOMER_ID) NAME,
    AMOUNT AS AMT, '대출' AS TYPE_
FROM
    (SELECT CUSTOMER_ID, AMOUNT, AVG(AMOUNT) OVER() AVG_AMT
    FROM LOANS
    WHERE STATUS = 'APPROVED')L
WHERE AMOUNT > AVG_AMT
UNION ALL
SELECT
    (SELECT NAME FROM CUSTOMERS C WHERE C.CUSTOMER_ID=A.CUSTOMER_ID),
    BALANCE, '계좌' AS TYPE_
FROM
    (SELECT CUSTOMER_ID, BALANCE, AVG(BALANCE) OVER() AVG_AMT
    FROM ACCOUNTS)A
WHERE BALANCE > AVG_AMT
;

-- 7번
SELECT * FROM (
SELECT DISTINCT JOB_ID "직무 ID",
    (SELECT DEPARTMENT_NAME FROM DEPARTMENTS WHERE E.DEPARTMENT_ID = DEPARTMENT_ID) "부서 이름",
    ROUND(AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID)) "직무별 평균 급여",
    ROUND(AVG(SALARY) OVER (PARTITION BY JOB_ID)) "부서별 평균 급여"
FROM EMPLOYEES E)
WHERE "직무별 평균 급여" >= "부서별 평균 급여"
    AND "부서 이름" IS NOT NULL;

-- 8. 지점별 고객 수와 승인율
-- 지점별 대출 건수를 계산하고, 대출 승인율(APPROVED 상태 건수 / 전체 건수 * 100)을 계산하여 결과를 출력하세요. 
-- 대출 승인율은 반올림하여 소수점 아래 둘째자리까지 표현합니다.
SELECT BRANCH_ID "지점 ID", 
    ROUND(COUNT(CASE
            WHEN STATUS = 'APPROVED' THEN 1
            END)/COUNT(*), 2) "대출 승인율"
FROM LOANS
GROUP BY BRANCH_ID;

-- 9. 직무별 최고 급여를 받는 직원
-- 각 직무에서 가장 높은 급여를 받는 직원의 이름과 급여를 조회하세요. 
-- 직무 기준으로 정렬하세요.
SELECT * FROM (
    SELECT NAME, SALARY, JOB_ID,
        RANK() OVER (PARTITION BY JOB_ID ORDER BY SALARY) AS RANK
    FROM EMPLOYEES)
WHERE RANK = 1
ORDER BY JOB_ID;

-- 10번
SELECT (SELECT DEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = E.DEPARTMENT_ID) "부서 이름",
    COUNT(MANAGER_ID) "상사 있음", COUNT(*) - COUNT(MANAGER_ID) "상사 없음"
FROM EMPLOYEES E
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID;
```

## 옵션 사용 유의사항

- ROWS와 RANGE 용도에 따라 신중히 선택
- 데이터셋이 클 경우 성능에 유의
    
    개발DB → 실제DB 차이 고려
    

```sql
-- 윈도우 함수 예제
SELECT CUSTOMER_ID, ACCOUNT_ID, BALANCE,
    SUM(BALANCE) OVER (PARTITION BY CUSTOMER_ID
    ORDER BY ACCOUNT_ID) AS CUM_BALANCE
FROM ACCOUNTS;

SELECT BRANCH_ID, LOAN_ID, AMOUNT,
    MAX(AMOUNT) OVER
    (PARTITION BY BRANCH_ID) AS MAX_LOAN_ACCOUNT
FROM LOANS;

SELECT STATUS, LOAN_ID,
    COUNT(LOAN_ID) OVER
    (PARTITION BY STATUS) AS STATUS_COUNT
FROM LOANS;
```

# 계층 쿼리

- 데이터가 부모-자식 관계로 구성된 계층적 구조를 조회하기 위한 쿼리
- 트리 구조 데이터를 표현하고 탐색하는 데 사용

## 계층 쿼리 동작 원리

- **START WITH**
    
    계층 구조의 시작점 지정
    
- **CONNECT BY**
    
    부모-자식 관계를 정의
    
- **PRIOR**
    
    CONNECT BY절 내에서 계층의 방향성을 지정
    
- **ORDER SIBLINGS BY**
    
    동일 레벨의 데이터 정렬
    
    ORDER BY를 사용하면 계층이 모두 섞여버린다.
    
- **LEVEL**
    
    계층 깊이를 나타내는 가상 컬럼
    

```sql
SELECT 컬럼명, LEVEL
FROM 테이블명
START WITH 시작 조건
CONNECT BY PRIOR 부모컬럼 = 자식컬럼;
```

## 계층쿼리 예제

```sql
-- 계층 쿼리 예시
SELECT EMPLOYEE_ID, NAME, LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
ORDER BY LEVEL;

-- SYS_CONNECT_BY_PATH 예시
SELECT EMPLOYEE_ID, NAME,
    LTRIM(SYS_CONNECT_BY_PATH(NAME, '->'), '->') AS PATH
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;

-- 역방향 예시
SELECT EMPLOYEE_ID, NAME, DEPARTMENT_ID
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 56
CONNECT BY EMPLOYEE_ID = PRIOR MANAGER_ID;

-- SIBLINGS 정렬
SELECT EMPLOYEE_ID, NAME, LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
ORDER SIBLINGS BY NAME DESC;

-- 계층 쿼리 예제
SELECT CATEGORY_ID,
    PARENT_CATEGORY_ID,
    LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '>'), '>') AS CATE,
    LEVEL
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;

SELECT CATEGORY_ID,
    PARENT_CATEGORY_ID,
    LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '>'), '>') AS CATE
FROM SHOPPING_CATEGORIES
START WITH CATEGORY_NAME = 'Electronics'
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;

SELECT CATEGORY_ID, CATEGORY_NAME, LEVEL
FROM SHOPPING_CATEGORIES
WHERE LEVEL = 2
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;

SELECT CATEGORY_ID, CATEGORY_NAME
FROM SHOPPING_CATEGORIES
WHERE CATEGORY_ID NOT IN (
    SELECT DISTINCT PARENT_CATEGORY_ID
    FROM SHOPPING_CATEGORIES
    WHERE PARENT_CATEGORY_ID IS NOT NULL);

SELECT C1.CATEGORY_ID,
    C1.CATEGORY_NAME,
    C2.CATEGORY_NAME AS PARENT_CATEGORY_NAME
FROM SHOPPING_CATEGORIES C1
LEFT JOIN SHOPPING_CATEGORIES C2
    ON C1.PARENT_CATEGORY_ID = C2.CATEGORY_ID;
```
