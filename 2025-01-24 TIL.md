# 1/24 단원 Test

- 8/10
1. VIEW의 장점
    
    물리적view는 일반적으로 많이 사용되는 view가 아니다.
    
    데이터 저장 공간 절약 → 가상 컬럼
    
2. 그룹 함수가 적용되지 않은 SELECT절
    
    그룹함수 = 집계함수
    
    GROUP BY 절에 포함되어야 한다.

# WITH 문

- SQL에서 CTE를 정의하기 위한 구문
- 서브쿼리를 재사용 가능하고 가독성 높게 작성할 수 있도록 지원
- 복잡한 SQL 쿼리를 읽기 쉽고 관리 가능하게 구조화
- 동일한 서브쿼리를 반복적으로 재작성하지 않아도 됨
- 재귀 쿼리 작성 시 활용 (흔하게 사용은 X)

## 단일 CTE

```sql
WITH DEPARTMENTSALARY AS (
    SELECT DEPARTMENT_ID, ROUND(AVG(SALARY), 2) AS AVG_SALARY
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID
    ORDER BY DEPARTMENT_ID NULLS LAST)
SELECT *
FROM DEPARTMENTSALARY
WHERE AVG_SALARY > 5000;
```

## 다중 CTE

```sql
WITH CTE1 AS (
	SELECT ...
),
WITH CTE2 AS (
	SELECT ...
	FROM CTE1
)
SELECT ...
FROM CTE2
```

→ 해석이 복잡해질 수 있기 때문에 권장하지는 않는다.

## 재귀 CTE

```sql
WITH NUMBERS(NUM) AS (
	SELECT 1 AS NUM
	FROM DUAL
	UNION ALL
	SELECT NUM + 1 AS NUM
	FROM NUMBERS
	WHERE NUM < 10
)
SELECT B.NUM
FROM NUMBERS B;
```

→ 재귀 탈출 조건을 잘 정의해야 한다. (무한루프)

## WITH문 사용 시 유의사항

- CTE는 임시적으로 데이터를 메모리에 저장하려 처리 → PGA 이용
- PGA 부족 → Temp Tablespace 공간 사용
- CTE의 결과를 도출하는 데 복잡한 계산이 이루어져야 하고, 데이터량도 많은 경우에는 초기 비용이 들더라도 Temp 영역에 저장해 두는 것이 유리할 수 있음
- 데이터량이 적고 결과 도출의 비용이 크지 않을 경우 Temp 영역 저장 비용이 더 커버릴 가능성 존재 (PGA로 해결이 되는지 확인 필요)

## Temp Tablespace 사용 확인

- 데이터 정렬 작업(ORDER BY, GROUP BY, DISTINCT) 에서 PGA를 다 사용하면 TEMP Tablespace에 데이터 기록
- 실행 계획에서 SORT와 같은 키워드로 나타남
- TempSpc는 쿼리 실행 시 예상되는 TEMP Tablespace 사용량을 나타냄
- PGA로만 해결이 된 경우 나타나지 않음

# JOIN 최적화

## NESTED LOOP JOIN

- 중첩 FOR문과 유사한 형태
- DRIVING TABLE → DRIVEN TABLE
- OLTP성 쿼리에 적합
- use_nl

JOIN 순서에 따라 조회 수가 많이 달라진다.

## HASH JOIN

- JOIN 컬럼에 인덱스가 없어 NL JOIN이 효과적이지 못한 상황에 대한 대안
- JOIN 컬럼에 인덱스가 있지만 DRIVING TABLE에서 DRIVEN TABLE로의 액세스량이 많아 RANDOM ACCESS 부하가 심한 경우
- 두 테이블 중 작은 테이블을 메모리에 생성
- 큰 테이블이 DRIVING 테이블이 되어 JOIN 데이터의 HASH값을 메모리의 HASH값과 비교
- TABLE RANDOM ACCESS 부하가 없음

HASH JOIN의 빠른 속도 때문에 모든 JOIN을 HASH JOIN으로 처리하려는 유혹 존재

→ INDEX는 한 번 생성해 놓으면 계속해서 사용할 수 있는 영구적인 오브젝트

HASH TABLE은 단 하나의 쿼리를 위해 생성하고 JOIN이 끝나면 바로 소멸하는 자료구조

- 수행빈도가 낮고 시간이 오래 걸리는 OLTP성 쿼리에 적합

# 실행 계획

- SQL로 요청한 데이터를 어떻게 꺼내 올 것인가에 대한 PLAN
- 성능 병목 현상을 파악하는 데 유용
- 높은 확률로 OPTIMIZER가 결정한 실행 계획이 최선인 경우가 많음

## XPLAN

- DBMS_XPLAN 패키지를 사용하여 실행 계획을 읽기 쉽게 출력
    
    ```sql
    -- 실행 계획
    EXPLAIN PLAN FOR 
    SELECT * FROM EMPLOYEES;
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
    
    SELECT * FROM (DBMS_XPLAN.DISPLAY_CURSOR(NULL, NULL, 'ALLSTATS LAST'));
    ```
    

## 조건

- **Access 조건**
    - 인덱스나 테이블에 접근할 때 사용하는 조건, 검색 제한
    - 데이터 액세스를 효율적으로 제한하여 불필요한 I/O 줄임
- **Filter 조건**
    - 데이터를 Access 반환한 후 추가적으로 필터링하는 조건
    - Access 조건보다 덜 효율적

## 실행 계획 분석

- **TABLE ACCESS FULL**
    
    데이블의 모든 행을 스캔하는 작업
    
- **TABLE ACCESS BY INDEX ROWID**
    
    인덱스를 통해 식별된 행을 기반으로 데이블 데이터를 읽는 작업
    
- **INDEX RANGE SCAN**
    
    범위 조건에 따라 인덱스를 검색
    
- **INDEX UNIQUE SCAN**
    
    고유 인덱스를 사용하여 단일 행을 검색 (가장 빠름)
    
- **NESTED LOOPS**
    
    중첩 반복을 사용해 두 소스를 결합하는 작업
    
- **HASH JOIN**
    
    HASH 알고리즘을 사용하여 데이터를 결합하는 작업
    
- **SORT AGGREGATE**
    - 집계함수를 계산하기 위한 작업
    - GROUP BY 없이 집계 함수가 실행될 때 사용
    - 데이터를 정렬하지 않고 집계 연산만 수행
- **SORT BY GROUP**
    
    GROUP BY 조건을 처리하기 위해 데이터를 정렬하는 작업
    
- **SORT ORDER BY**
    - 데이터를 정렬하는 작업
    - 메모리 또는 임시 테이블 공간을 사용하여 데이터 정렬
    - 정렬 작업 비용이 많이 드는 경우 적절한 인덱스 활용
- **HASH GROUP BY**
    - HASH 알고리즘을 사용하여 데이터를 그룹화하는 작업
    - 대량 데이터를 그룹화하는 경우 SORT GROUP BY보다 효율적
- **VIEW PUSHED PREDICATE**
    
    쿼리에서 뷰를 사용할 때 필터 조건을 뷰 내부로 이동시켜 처리 성능을 높임
    
- **MATERIALIZE**
    
    뷰나 서브쿼리 결과를 메모리에 임시로 저장하는 작업
    
- **WINDOW SORT**
    
    윈도우 함수를 처리하기 위한 정렬 작업
    

# 사용자 정의 함수

- 사용자가 특정 작업을 수행하기 위해 정의한 PL/SQL 코드 블록
- 반복적인 작업을 자동화하고 코드 재사용성을 높이기 위해 사용
- 주로 입력 값을 받아 처리 후 결과를 반환

## 사용자 정의 함수 특징

- 특정 작업 수행 후 값을 반환
- SQL문에서 호출 가능
- 재사용 가능
- 복잡한 논리를 캡슐화하여 유지보수 용이

## 사용자 함수 구성 요소

- 함수 이름
- 매개변수
- 반환값
- PL/SQL 코드

## 사용자 정의 함수 생성

```sql
CREATE OR REPLACE FUNCTION 함수이름 (매개변수 IN 데이터타입)
RETURN 반환타입 IS
BEGIN
	-- 작업 수행
	RETURN 결과값;
END;
```

함수를 많이 호출하면 느려질 수 있다.

→ 스칼라 서브쿼리로 만들어서 최적화

## 오류 처리

사용자 정의 함수에서 오류가 발생하면 **EXCEPTION 구문**으로 처리 가능

## 사용자 정의 함수 장점

- 재사용성
- 유지보수 용이성
- 성능 최적화

## 사용자 정의 함수 단점

- 복잡성
    
    지나치게 많은 함수 사용하면 코드가 복잡해짐
    
- 디버깅 어려움
    
    서버 측에서 실행되기 때문에 디버깅이 어려울 수 있음
    
- 의존성 문제
    
    DB 스키마 변경 시 함수 수정 필요
    

## 사용자 정의 함수와 보완

- 권한 제한
    
    함수 생성 및 실행 권한을 관리
    
- SQL Injection
    
    쿼리문을 데이터로 입력하여 시스템에 악영향을 줌
    
    → 매개변수 값을 안전하게 처리
    
- 데이터 무결성
    
    함수가 데이터 무결성을 해치지 않도록 설계
    

## 사용자 정의 함수 실무 활용 사례

- 할인 계산, 세금 계산 비즈니스 로직
- 데이터 포맷팅 (전화번호 형식 변환)
- 복잡한 데이터 계산 자동화

## 사용자 정의 함수 변경 및 삭제

- 변경
    
    ```sql
    CREATE OR REPLACE FUNCTION 함수이름 ...;
    ```
    
- 삭제
    
    ```sql
    DROP FUNCTION 함수이름;
    ```
    

## 사용자 정의 함수 작성 팁

- 명확하고 간결한 함수 이름 사용
- 함수는 단일 작업에 집중
- 매개변수와 반환값에 대한 데이터 타입 명확히 지정
- EXCEPTION 블록으로 오류 처리 강화

# REDO와 UNDO

- **REDO**
    
    데이터베이스의 변경 내용을 복구하기 위한 로그
    
- **UNDO**
    
    데이터 변경 이전 상태를 저장하여 롤백하거나 트랜잭션을 취소할 수 있게 함
    
- 데이터 무결성과 복구 기능을 제공

## REDO 역할

- 데이터베이스가 비정상적으로 종료되었을 때 복구
- 커밋된 트랜잭션의 변경 내용을 재생하여 데이터 무결성 보장
- REDO 로그는 디스크에서 지속적으로 기록됨

## UNDO 역할

- 트랜잭션 롤백 시 변경 내용을 원래 상태로 복구
- 읽기 일관성을 제공하여 가른 세션이 데이터 변경 전 상태를 조회 가능
    
    (MVCC)
    
- 복구 또는 취소 작업을 위해 UNDO 세그먼트를 사용

## REDO vs UNDO

- REDO: 변경 내용을 재생 (재적용)
- UNDO: 변경 내용을 취소 (원래 상태 복구)
- REDO는 커미시된 트랜잭션 대상, UNDO는 롤백 또는 읽기 일관성 대상

## REDO 로그 구조

- REDO 로그 파일: 데이터 변경 내용을 저장
- 로그 버퍼: 메모리 내 변경 내용을 저장
- 로그 파일 스위칭: REDO 로그가 가득 차면 다음 로그 파일로 이동

## UNDO 세그먼트

- UNDO 데이터는 UNDO 테이블스페이스에 저장
- 각 트랜잭션은 UNDO 세그먼트를 사용하여 데이터 변경 이전 상태를 저장
- UNDO 데이터는 트랜잭션 완료 후 재사용 가능

## REDO와 UNDO 동작 원리

- 트랜잭션 수행 시
    - 변경 내용은 REDO 로그로 기록
    - 변경 전 데이터는 UNDO 세그먼트에 저장
- 커밋 시
    - REDO 로그는 영구 저장
    - UNDO 데이터는 재사용 가능

## COMMIT된 데이터 복구 방법

- 플래시백 쿼리
    
    오라클 DB는 UNDO 테이블스페이스를 사용하여 과거 데이터 조회 가능
    
    플래시백 쿼리는 특정 시점의 데이터를 복구하는데 유용
    
- AS OF TIMESTAMP 절을 사용하여 5분 전 데이터를 조회
    
    ```sql
    SELECT *
    FROM EMPLOYEES
    AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '5' MINUTE);
    ```
    

## 플래시백을 이용한 복구의 전제 조건

- 설정된 보존 기간 (UNDO_RETENTION) 안에 복구 해야함
    
    ```sql
    -- UNDO_RETENTION 설정 값 확인
    SELECT NAME, VALUE
    FROM v$PARAMETER
    WHERE NAME = 'UNDO_RETENTION';
    ```
    

# SQL Injection

- 공격자가 입력 필드나 URL에 악의적인 SQL 코드를 삽입하여 DB를 공격하는 기법
- 목적
    - 민감한 데이터 유출
    - 데이터 변경
    - 시스템 권한 탈취

## SQL Injection 사례

```sql
SELECT * FROM CUSTOMERS WHERE NAME
= :name_val;
-- -> 공격자가 name_val에 'A' OR 1=1 을 입력
```
