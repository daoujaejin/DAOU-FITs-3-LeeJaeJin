## 11. 상속과 관련된 constructor의 특징

- constructor (생성자)는 상속되지 않는다.
    
    프로그래머가 명시하지 않아도 constructor가 호출될 때 자동으로
    
    상위 class의 constructor가 호출된다.
    
- 생성자 안에서 `super()` 메소드로 상위 class의 생성자를 호출한다.
    
    super 함수보다 먼저 다른 행동이 오면 안된다.
    
    명시적으로 호출하지 않으면 자동으로 먼저 호출된다.
    
- 상위 클래스의 생성자에 매개변수가 있으면, 생성자 호출 시 에러가 날 수 있기 때문에, 항상 기본 생성자는 만드는 것이 좋다.
- **Shadow, Annotation**
    
    상위 class와 같은 이름의 field 요소가 있으면 먼저 (상위 클래스에서) 정의된 변수나 method가 가려진다.
    
    ```java
    @Override
        public void sleep() {
            super.sleep();
        }
    ```
    

## 12. method overriding

- 부모로부터 물려받은 method의 내용을 하위 class에서 다시 정의하는 것
- method overriding의 조건
    - method의 이름이 같다.
    - method의 return type이 같다.
    - 매개변수의 개수와 type이 같다.
    - access modifier가 부모보다 같거나 더 넓어야 한다.

## 13. is-a Relationship

상속 관계는 is-a relationship 관계이다.

= `sub class is a super class`

sub class type 자리에 super class type을 사용해도 된다.

→ **Polymorphism (다형성)**

## 14. 네가지 키워드

- `this`
    
    자기 자신 instance를 가리킴
    
- `super`
    
    기본적으로 this와 같으나, 상위 class의 타입으로 바뀐다.
    
- `this()`
    
    오버로딩 된 다른 생성자를 호출하기 위해 사용
    
- `super()`
    
    상위 class의 생성자를 호출하기 위해 사용
    

→ this()와 super()가 공존할 수는 없다.

field는 동적바인딩이 일어나지 않는다.

method는 @Override에 의해 동적바인딩이 된 함수를 찾아간다.

```java
package Inheritance;

class SuperClass {
    static int staticCall(String msg) {
        System.out.println(msg);
        return 0;
    }

    int a = staticCall("1번 문장입니다.");
    static int b = staticCall("2번 문장입니다.");

    public SuperClass() {
        staticCall("3번 문장입니다.");
    }

    public SuperClass(int i) {
        this();
        staticCall("4번 문장입니다.");
    }

    public void myFunc() {
        System.out.println("5번 문장입니다.");
    }
}
```

```java
package Inheritance;

public class Exam01_InheritanceOrder extends SuperClass {
    int c = staticCall("6번 문장입니다.");
    static int d = staticCall("7번 문장입니다.");

    public Exam01_InheritanceOrder() {
        super(100);
        staticCall("8번 문장입니다.");
        super.myFunc();
    }

    @Override
    public void myFunc() {
        System.out.println("9번 문장입니다.");
    }

    public static void main(String[] args) {
        System.out.println("10번 문장입니다.");
        SuperClass obj = new Exam01_InheritanceOrder();
        obj.myFunc();
        // casting 할 때 연산자 우선순위 조심
        ((Exam01_InheritanceOrder)obj).c = 1;
    }
}
```

## 15. Abstraction (추상화)

→ 객체 모델링하기 위해 사용

현실에 있는 대상과 특징을 객체화한다.

## 16. Encapsulation (캡슐화)

class로 데이터를 묶어서 다룬다.

→ 데이터와 기능을 묶어서 관리

class 단위로 재활용성을 높이고, 에러발생을 최소화한다.

## 17. Information Hiding (정보 은닉)

외부에서 알 필요가 없는 field, method를 외부에 노출시키지 않는다.

`private` 접근제어자 사용

## 18. final keyword

- class 앞에 final이 붙은 경우: 해당 class를 상속할 수 없음을 의미
- field 앞에 final이 붙은 경우: 해당 field 값을 변경할 수 없음을 의미
- method 앞에 final이 붙은 경우: 해당 method를 하위 class에서 overriding할 수 없음을 의미

## 19. abstract class

= 덜 만들어진 class

- instance를 생성할 수 없다.
- abstract class의 abstract method를 상속받은 하위 class에서 overriding하여 instance를 생성한다.

## 20. Polymorphism & Dynamic binding

**다형성**: 부모 객체 타입으로 다양한 형태의 자식 객체를 생성, 사용할 수 있는 것을 의미

- 같은 상위 class 형태로 여러 하위 instance들을 맞춘 뒤 배열과 같은 자료구조로 관리를 할 수 있다.

## 21. interface

class의 특수한 케이스

- **field** 영역에는 `public static final` 이 자동으로 붙는다.
- **method**는 모두 abstract method이다.

→ interface로부터는 직접적인 객체생성이 불가능하다.

- interface는 `implement` 로 구현을 해서 사용한다.
- interface에 있는 abstract method들을 모두 override하여 구현

**다중구현**을 제공한다.

= class는 단일 상속만 가능하지만, interface는 여러 interface로부터 다중 구현을 할 수 있다.

## 22. 실습문제

- “-”:  private
    
    → getter, setter 필요
    
- “+”: public
- “#”: protected

- 확장 for문 → 배열과 같은 자료구조를 사용할 때 적합
    
    ```java
            for (int i = 0; i < 3; i++) {
                System.out.println(tvArray[i].toString());
            }
    
            for (Tv t : tvArray) {
                System.out.println(t);
            }
    ```
    

# 주요 class

## 1. Object class

= 모든 class의 최상위 class

### 1-1. equals()

→ 두 객체가 논리적으로 동등한지 비교하기 위한 메서드

- String은 특수하게 그냥 비교연산자를 사용해도 된다.
- 기본적으로 제공되는 구현은 객체의 메모리 주소를 비교해준다.
    
    → 오버라이딩을 이용해서 비교하는 방법을 내가 원하는 방식으로 바꿔서 사용한다.
    

```java
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof MyObjectClass) {
			return false;
		}
		Student target = (Student)obj;
		boolean result = false;
		if((this.getName().equals(target.getName())) && 
				(this.getAge() == target.getAge())) {
			result = true;
		}
		return result;
	}
```

매개변수 형식이 Object이기 때문에 모든 객체가 들어갈 수 있다.

비교할 것

- 객체 데이터 타입 비교
- 내부 field 내용 비교

```java
class MyTest {

	public static void main(String[] args) {
		Student s1 = new Student("홍길동", 20);
		Student s2 = new Student("홍길동", 20);
		
		System.out.println(s1 == s2);  // false
		System.out.println(s1.equals(s2));  // true
	}

}
```

### 1-2. toString()

객체를 나타내는 내용을 문자열로 바꿔주는 메서드

```java
package lecture;

class Student {
	private String name;
	private int age;
	
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	
	@Override
	public String toString() {		
		return this.getName() + " " + this.getAge();
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
	
}

class MyTest {

	public static void main(String[] args) {
		
		Student s1 = new Student("홍길동", 20);

		System.out.println(s1);
	}

}
```
